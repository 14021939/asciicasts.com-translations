<p>Letztes Wochenende fand das Rails 3.1 HackFest statt und Dank der harten Arbeit aller Beteiligten ist nun der 5. Release Kandidat von Rails 3.1 verfügbar.Diese Release enthält wichtige Verbesserungen für Mountable Enginges. Mountable Engines erlauben es eine Railsanwendung in einer anderen einzubinden, was auch Thema dieser Folge sein soll.</p>

<p>Vielleicht erinnerst du dich an das Exception Notification Plugin aus Folge <a href="http://railscasts.com/episodes/104-exception-notifications">Episode 104</a>. Wenn man dieses einer Anwendung hinzufügt, speichert es jeden Fehler der Anwendung in einer Datenbank. Des weiteren erlaubt das Plugin die Anzeige der Fehler über eine Benutzerschnittstelle. In dieser Folge erstellen wir das Plugin neu - allerdings dieses mal als Mountable Engine.</p>

<h3>Vorbereitung</h3>

<p>Bevor wir unsere Engine implementieren, müssen wir sicherstellen, dass wir Rails in der Version 3.1 Release Kandidat 5 oder neuer verwenden. Die neueste Version können wir wie folgt installieren</p>

<pre class="terminal">$ gem install rails --pre</pre>

<p>Haben wir erst einmal die richtige Railsversion installiert, können wir damit beginnen, unsere Mountable Engine zu erzeugen. Es ist nicht notwendig, dass wir diese in einer bereits existierenden Railsanwendung erstellen. Das erstellen einer Engine ist mit der Initiierung einer Railsanwendung über das Kommando <code>rails new</code> vergleichbar. Der einzige Unterschied ist, dass wir stattdessen <code>rails plugin new</code> ausführen. Da unsere Anwendung Ausnahmen behandelt, nennen wir sie <code>uhoh</code>. Zusätzlich müssen wir die Option <code>--mountable</code> verwenden, um tatsächlich eine einbindbare - Mountable - Engine zu erhalten.</p> 

<pre class="terminal">$ rails plugin new uhoh --mountable</pre>

<p>Die Verzeichnisstruktur unserer Engine ähnelt stark der einer normalen Railsanwendung und das ist sie auch grundsätzlich. Diese ist eben nur so gestaltet, dass sie in eine andere Anwendung eingebunden werden kann. Aus diesem Grund sind hier auch kleine Unterschiede zu erkennen sind. Innerhalb der Anwendung befinden sich einige über einen Namensraum abgegrenzte Verzeichnisse. Beispielsweise liegt die Datei <code>application_controller</code> im Verzeichnis <code>7app/controllers/uhoh</code>. Das gleiche gilt für die Dateien in den Verzeichnissen <code>assets</code>, <code>helpers</code> und <code>views</code>. Dies hilft den Code der Engine sauber vom Code der Anwendung, in die sie eingebunden wird, zu trennen. Das <code>assets</code> Verzeichnis bewirkt, dass wir nun nicht mehr ständig öffentliche Dateien (Assets) in den <code>public</code> Ordner kopieren müssen, sobald die Engine in eine Anwendung eingebunden wird. Darum kümmert sich nun die Asset Pipeline.</p>

<div class="imageWrapper">
  <img src="/system/photos/712/original/E277I01.png" width="800" height="502" alt="Die Verzeichnisstruktur einer Engine."/>
</div>

<p>Da öffentliche Dateien ebenfalls über einen Namensraum, dh. über einen bestimmten Ordner, abgegrenzt sind, muss dieser Ordner bei Verlinkungen mit angegeben werden. Für das Layouts Verzeichnis gilt das gleiche, auch wenn hier anscheinend ein Bug in RC5 eine zweite <code>application.html.erb</code> Datei erzeugt. Die zweite Datei außerhalb des <code>uhoh</code> kann einfach gelöscht werden. Wenn wir uns die andere Datei anschauen, sehen wir, dass alle Verlinkungen zu den öffentlichen Dateien auf das <code>uhoh</code> verweisen. Immer wenn wir Bilder oder andere Anlagen verlinken, dürfen wir diesen Namensraum nicht vergessen.</p>


<p class="codeFilePath">/app/views/layouts/uhoh/application.html.erb</p>
<pre class="ruby">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Uhoh&lt;/title&gt;
  &lt;%= stylesheet_link_tag    &quot;uhoh/application&quot; %&gt;
  &lt;%= javascript_include_tag &quot;uhoh/application&quot; %&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>

<p>Als nächstes schauen wir uns eine der Schlüsseldateien der Engine, <code>engine.rb</code> im <code>/lib/uhoh</code> Verzeichnis an.</p>

<p class="codeFilePath">/lib/uhoh/engine.rb</p>
<pre class="ruby">module Uhoh
  class Engine &lt; Rails::Engine
    isolate_namespace Uhoh
  end
end</pre>

<p>Diese Klasse erbt von <code>Rails::Engine</code> und ist der zentrale Punkt für spezifische Konfigurationen. Innerhalb der Klasse wird bereits <code>isolate_namespace</code> aufgerufen. Das bedeuted, dass die Engine als eigene isolierte Einheit behandelt wird und sich nicht um die Anwendung kümmern braucht, in die sie eingebunden wird.</p>

<p>Der letzte Teil der Engine auf den wir bei dieser kurzen Einweisung einen Blick werfen wollen, befindet sich im <code>/test</code> Verzeichnis. Innerhalb des Verzeichnisses <code>/test/dummy</code> ist eine Railsanwendung, welche uns zeigen soll, wie unsere Engine funktioniert, wenn sie eingebunden wird. Der Ordner <code>config</code> enthält eine <code>routes.rb</code> Datei. Diese wiederum ruft <code>mount</code> auf und übergibt die Engine Klasse, welcher ein Pfad zugewiesen ist.</p> 

<p class="codeFilePath">/test/dummy/config/routes.rb</p>
<pre class="ruby">Rails.application.routes.draw do
  mount Uhoh::Engine =&gt; &quot;/uhoh&quot;
end</pre>

<p>Wenn jemand deine Engine in seiner Anwendung installieren möchte, muss er genau dies tun - sie an was für einem Pfad auch immer einbinden. Dies ist eine Rackanwendung und somit wird jeder eintreffende Request an /uhoh weitergereicht an unsere <code>Engine</code> Klasse. Es ist eine gute Idee diese Zeile in die Installationsanweisung der README Datei der Engine einzufügen, damit Nutzer wissen, wie sie die Engine in die routes Datei ihrer Anwendung einbinden.</p>

<p>Auch wenn diese Dummyanwendung sich im Verzeichnis <code>/test</code> befindet, ist sie dennoch auch gut für manuelle Tests geeignet. Führen wir das Kommando <code>rails s</code> aus dem Verzeichnis unserer Engine aus, startet die Dummyanwendung. Rufen wir die Seite <a href="http://localhost:3000/uhoh/"><code>http://localhost:3000/uhoh/</code></a> auf, gelangen wir zu unserer Engine, da wir sie dort eingebunden haben. Wenn wir die Seite aufrufen, sehen wir eine Fehlermeldung, da wir den entsprechenden Controller noch nicht erstellt haben.</p>

<p>Das werden wir jetzt nachholen und einen <code>failures</code> Controller in der Engine erstellen. Hierfür können wir genauso wie in einer Railsanwendung Railsgeneratoren verwenden. Auch wenn wir uns in einer Engine befinden, brauchen wir keinen Namensraum angeben. Um das alles kümmert sich Rails selbst.</p>

<pre class="terminal">$ rails g controller failures index</pre>

<p>Hierdurch werden die gleichen Dateien erzeugt, wie wir sie auch bei einem normalen Controller erwarten, mit der Ausnahme, dass alles über den Namensraum in die richtigen Verzeichnisse verteilt wird. Als nächstes passen wir das Routing der Engine an, so dass die <code>root</code> Route auf die Index Action des Controllers verweist. Dies erledigen wir in der Datei <code>/config/routes.rb</code> der Engine.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">Uhoh::Engine.routes.draw do
  root :to =&gt; &quot;failures#index&quot;
end</pre>

<p>Wenn wir nun <a href="http://localhost:3000/uhoh/"><code>http://localhost:3000/uhoh/</code></a> aufrufen, sehen wir die zu der Action gehörige View.</p>

<div class="imageWrapper">
  <img src="/system/photos/713/original/E277I02.png" width="801" height="280" alt="Der Vorgabetext der Index View."/>
</div>

<p>Auf dieser Seite wollen wir eine Liste der aufgetretenen Ausnahmen anzeigen. Wir benötigen ein Model in dem wir diese Informationen speichern können und erzeugen deshalb ein einfaches <code>Failure</code> Model mit einem Message Feld.</p>

<pre class="terminal">$ rails g model failure message:text</pre>

<p>Nachdem wir das Model erstellt haben, stellt sich die Frage, wie wir die Datenbankmigrationen anstoßen? Innerhalb der Engine können wir wie üblich <code>rake db:migrate</code> ausführen und alles funktioniert wie erwartet. Allerdings wird dies nicht funktionieren, wenn jemand versucht die Engine in seine Anwendung einzubinden, da <code>rake</code> keine Migrationen von eingebundenen Engines ausführt. Wir müssen unseren Nutzern mitteilen, das sie stattdessen <code>rake uhoh:install:migrations</code> ausführen sollen. Dadurch werden die Migrationen der Engine in die Anwendung selbst kopiert, sodass anschließend <code>rake db:migrate</code> wie gewünscht funktioniert. Es ist eine gute Idee diese Information in die Installationsanleitung der Engine aufzunehmen.</p>

<p>Die Railsconsole funktioniert ebenfalls wie erwarten in einer Engine und wir werden sie nun zur Erstellung eines Beispiel-<code>Failure</code>s verwenden.</p>

<pre class="ruby">Uhoh::Failure.create!(:message =&gt; &quot;hello world!&quot;)</pre>

<p>Beachte, dass wir immer den Namensraum mit angeben müssen, wenn wir auf eine Klasse verweisen. Da wir jetzt einen Failure haben, wollen wir ihn nun in unserer <code>index</code> Action unseres <code>FailuresController</code>s anzeigen.</p>

<p class="codeFilePath">/app/controllers/uhoh/failures_controller.rb</p>
<pre class="ruby">module Uhoh
  class FailuresController &lt; ApplicationController
    def index
      @failures = Failure.all
    end
  end
end</pre>

<p>Im Gegensatz zur Console brauchen wir hier keinen Namensraum angeben, da wir ja bereits innerhalb des <code>Uhoh</code> Moduls sind. In der View schreiben wir etwas Code, um über eine Schleife alle Fehler in einer Liste anzeigen zu lassen.</p>

<p class="codeFilePath">/app/views/uhoh/failures/index.html.erb</p>
<pre class="ruby">&lt;h1&gt;Failures&lt;/h1&gt;
&lt;ul&gt;
  &lt;% for failure in @failures %&gt;
  &lt;li&gt;&lt;%= failure.message %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;</pre>

<p>Wenn wir nun die Seite neu laden, sehen wir den eben hinzugefügten <code>Failure</code>.</p>

<div class="imageWrapper">
  <img src="/system/photos/714/original/E277I03.png" width="801" height="280" alt="Our failure shown in the list."/>
</div>

<h3>Catching Exceptions</h3>

<p>Now we have a method of recording failures we&rsquo;ll need to generate one every the application the engine is embedded in raises an exception. To test this we&rsquo;ll need a way to simulate an exception in the dummy application. To do this we&rsquo;ll move into our engine&rsquo;s dummy application&rsquo;s directory and generate a controller called <code>simulate</code> with a <code>failure</code> action.</p>

<p class="terminal">$ rails g controller simulate failure</p>

<p>Inside the action we&rsquo;ll raise an exception.</p>

<p class="codeFilePath">/test/dummy/app/controllers/simulate_controller.rb</p>
<pre class="ruby">class SimulateController &lt; ApplicationController
  def failure
    raise &quot;Simulating an exception&quot;
  end
end</pre>

<p>If we visit that action in a browser we&rsquo;ll see the exception as expected.</p>

<div class="imageWrapper">
  <img src="/system/photos/715/original/E277I04.png" width="800" height="420" alt="The exception shown in a browser."/>
</div>

<p>We&rsquo;ll need to change our engine now so that it listens for that exception and creates a new <code>Failure</code> record when it&rsquo;s raised. The solution we&rsquo;ll use for this isn&rsquo;t very efficient but it&rsquo;s simple and it will work for our case. We&rsquo;ll start by creating an initializer in our engine. There&rsquo;s no <code>initializers</code> directory in the engine&rsquo;s config directory but we can create one and initializers placed in it will work. In this directory we&rsquo;ll create a file called <code>exception_handler.rb</code>.</p>


<p class="codeFilePath">/app/config/exception_handler.rb</p>
<pre class="ruby">ActiveSupport::Notifications.subscribe &crarr;
  &quot;process_action.action_controller&quot; do &crarr;
  |name, start, finish, id, payload|
  if payload[:exception]
    name, message = *payload[:exception]
    Uhoh::Failure.create!(:message =&gt; message)
  end
end</pre>

<p>In this file we subscribe to a notification (notifications were covered in detail back in episode 249[<a href="http://railscasts.com/episodes/249-notifications-in-rails-3">watch</a>, <a href="http://asciicasts.com/episodes/249-notifications-in-rails-3">read</a>]), listening to a notification that tells us that an action was processed. When an action is processed we can check to see if the <code>payload</code> contains an exception. If it does we know that an exception has been raised and we can store its message in a new <code>Failure</code>.</p>

<p>We&rsquo;ll need to restart the server before we test this. We can then visit <a href="http://localhost:3000/simulate/failure"><code>http://localhost:3000/simulate/failure</code></a> again to raise an exception. Once we&rsquo;ve seen the exception we&rsquo;ll see it when we go to <a href="http://localhost:3000/uhoh"><code>http://localhost:3000/uhoh</code></a>.</p>

<div class="imageWrapper">
  <img src="/system/photos/716/original/E277I05.png" width="800" height="420" alt="Our new exception shown in the list."/>
</div>

<h3>Handling URLs in Engines</h3>

<p>Any URL helpers we use inside an engine will generate URLs for that engine. For example if we add a link to the root URL from our failures <code>index</code> page this link will point to the root URL for the engine, not for any application it&rsquo;s embedded in.</p>

<p class="codeFilePath">/app/views/uhoh/failures/index.html.erb</p>
<pre class="ruby">&lt;p&gt;&lt;%= link_to &quot;Failures&quot;, root_url %&gt;&lt;/p&gt;</pre>

<p>This link points to <a href="http://localhost:3000/uhoh"><code>http://localhost:3000/uhoh</code></a> which is the engine&rsquo;s root URL. This is the same page that the link is on as the root URL is defined in the routes to point to the <code>FailuresController</code>&rsquo;s <code>index</code> action. We can create links to the application itself by calling URL helpers on <code>main_app</code> like this:</p>

<p class="codeFilePath">/app/views/uhoh/failures/index.html.erb</p>
<pre class="ruby">&lt;p&gt;&lt;%= link_to &quot;Failures&quot;, root_url %&gt;&lt;/p&gt;
&lt;p&gt;&lt;%= link_to &quot;Simulate Failure&quot;, main_app.simulate_failure_path %&gt;&lt;/p&gt;</pre>
  
<p>This gives us a link to the Simulate Failure page in the app at <a href="http://localhost:3000/simulate/failure"><code>http://localhost:3000/simulate/failure</code></a>.</p> 

<p>What if we want to do this the other way around and have a link to the engine from the application? The first thing we need to do here is change the line in the application&rsquo;s routes file that mounts the engine and give it a name using the <code>:as</code> option.</p>

<p class="codeFilePath">/test/dummy/config/routes.rb</p>
<pre class="ruby">Rails.application.routes.draw do

  get &quot;simulate/failure&quot;

  mount Uhoh::Engine =&gt; &quot;/uhoh&quot;, :as =&gt; &quot;uhoh_engine&quot;
end</pre>

<p>We can then access the engine&rsquo;s URL helper&rsquo;s by calling them as methods of <code>uhoh_engine</code>. To demonstrate this we&rsquo;ll temporarily change our failure action so that instead of raising an exception if redirect&rsquo;s to the engine&rsquo;s root URL.</p>

<p class="codeFilePath">/test/dummy/app/controllers/simulate_controller.rb</p>
<pre class="ruby">class SimulateController &lt; ApplicationController
  def failure
    redirect_to uhoh_engine.root_url
  end
end</pre>

<p>If we visit <a href="http://localhost:3000/simulate/failure"><code>http://localhost:3000/simulate/failure</code></a> we&rsquo;ll be redirected to <a href="http://localhost:3000/uhoh"><code>http://localhost:3000/uhoh</code></a> as we&rsquo;re using that engine helper to redirect to one of its URLs. This is another feature that you might want to mention in your engine&rsquo;s README.</p>

<p>Our engine&rsquo;s functionality is pretty much complete now but the page that lists the failures looks pretty drab so we&rsquo;ll spice it up with some assets. First we&rsquo;ll add an image. We&rsquo;ve already found one to use and added it to the <code>/app/assets/images/uhoh</code> directory. To include it on the page we can use <code>image_tag</code> much as we would with any other image.</p>

<p class="codeFilePath">/app/views/uhoh/failures/index.html.erb</p>
<pre class="ruby">&lt;%= image_tag &quot;uhoh/alert.png&quot; %&gt;
&lt;h1&gt;Failures&lt;/h1&gt;
&lt;ul&gt;
  &lt;% for failure in @failures %&gt;
  &lt;li&gt;&lt;%= failure.message %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;%= link_to &quot;Failures&quot;, root_url %&gt;&lt;/p&gt;
&lt;p&gt;&lt;%= link_to &quot;Simulate Failure&quot;, &crarr;
  main_app.simulate_failure_path %&gt;&lt;/p&gt;</pre>
  
<p>We&rsquo;ll also include some CSS. SASS and CoffeeScript aren&rsquo;t available by default in engines, though they can be added as dependencies. If we add some CSS to the <code>failures.css</code> file it will be included automatically.</p>

<p class="codeFilePath">/app/assets/stylesheets/uhoh/failures.css</p>
<pre class="css">html, body {
  background-color: #DDD;
  font-family: Verdana;
}

body {
  padding: 20px 200px;
}

img {
  display: block;
  margin: 0 auto;
}

a {
  color: #000;
}

ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

li {
  background-color: #FFF;
  margin-bottom: 10px;
  padding: 5px 10px;
}</pre>

<p>The same applies with JavaScript. Any code placed in the <code>failures.js</code> file will also be automatically included.</p>

<p class="codeFilePath">/app/assets/javascripts/uhoh/failures.js</p>
<pre class="javascript">$(function() {
  $(&quot;li&quot;).click(function() {
    $(this).slideUp();
  });
});</pre>

<p>When we reload the page now it will look a lot better and we can hide an exception by clicking on it showing that the JavaScript was included.</p>

<div class="imageWrapper">
  <img src="/system/photos/717/original/E277I06.png" width="799" height="436" alt="Our failures page with CSS and JavaScript applied."/>
</div>

<p>That&rsquo;s it for this episode. Mountable engines are a great new feature in Rails 3.1 and are well worth taking a look at.</p>
