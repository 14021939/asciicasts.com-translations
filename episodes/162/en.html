<p>In this episode we&rsquo;re going to write a basic content management system that has a hierarchy of pages. We&rsquo;ll create a new Rails application from scratch and use <code>acts_as_tree</code> to help us define the relationships between the pages. The <code>acts_as_tree</code> plugin has been around for a while, but is still useful if you want to create a tree-like structure within a single model.</p>

<h3>Setting Up Our Application</h3>

<p>We&rsquo;ll start by creating a new Rails app, which we&rsquo;ll call <code>navigator</code>.</p>
<pre class="terminal">rails navigator</pre>
<p>That done we&rsquo;ll navigate to the application&rsquo;s directory and install the plugin from its <a href="http://github.com/rails/acts_as_tree/tree/master">Github page</a>.</p>
<pre class="terminal">
cd navigator
script/plugin install git://github.com/rails/acts_as_tree.git
</pre>
<p>Next we&rsquo;ll create a layout for our site. To generate the layout files we&rsquo;ll use one of Ryan Bates&rsquo;s <a href="http://github.com/ryanb/nifty-generators/tree/master">nifty generators</a>. If you don&rsquo;t have the gem for the generators installed you can install it with</p>
<pre class="terminal">
sudo gem install nifty-generators
</pre>
<p>We can then run the layout generator to create the application&rsquo;s layout file, stylesheet and a layout helper.</p>
<pre class="terminal">
script/generate nifty_layout
</pre>

<h3>Creating The Page Model</h3>

<p>Now that our application has a layout and will look a little better we can concentrate on creating the model for the pages. We want to create a resource called <code>Page</code> that can have tree-like behaviour and have sub-pages. A model that uses <code>acts_as_tree</code> needs to have an integer field called <code>parent_id</code> and we&rsquo;ll also give <code>Page</code> a string field called <code>name</code> and a text field called <code>content</code>. To make creating the <code>Page</code> resource easier we can use another of Ryan&rsquo;s nifty generators to create a scaffold</p>
<pre class="terminal">
script/generate nifty_scaffold page parent_id:integer name:string content:text
</pre>
<p>We now have a model, a controller, view files and all of the related items we need for our <code>Page</code> resource. To finish setting it up we&rsquo;ll need to run the database migration that the scaffold created.</p>
<pre class="terminal">
rake db:migrate
</pre>
<p>Among the view files generated by the scaffold will be a form to create or edit a <code>Page</code>. This form will have textboxes for each of the string or integer fields in the Page model, but a page&rsquo;s <code>parent_id</code> will always be the <code>id</code> of another page, so we&rsquo;ll replace the textbox for that field with a dropdown list that contains all of the pages.</p>

<p>The relevant section of <code>/app/views/pages/_form.html.erb</code> looks like this.</p>
<pre class="ruby">
    &lt;%= f.label :parent_id %&gt;&lt;br /&gt;
    &lt;%= f.text_field :parent_id %&gt;
</pre>
<p>The <code>text_field</code> can be replaced by a <code>collection_select</code>. This is generally what you want to use if you&rsquo;re defining a <code>belongs_to</code> relationship, as we are here, where each <code>Page</code> belongs to another <code>Page</code>.</p>
<pre class="ruby">
  &lt;%= f.label :parent_id %&gt;&lt;br /&gt;
  &lt;%= f.collection_select :parent_id, Page.all(:order =&gt; &quot;name&quot;), :id, :name, :include_blank =&gt; true %&gt;
</pre>
<p>The <code>collection_select</code> method takes a number of parameters. We need to pass it the name of the field; the collection of <code>Page</code> models, ordered by date; the fields from <code>Page</code> it should use for the value and text for each item and finally we&rsquo;ll tell it to include a blank item at the top of the list.</p>
<div class="imageWrapper">
  <img src="/system/photos/104/original/E162I01.png" width="800" height="492" alt="The page form now has a dropdown for the parent." />
</div>
<p>The form now has a dropdown for the parent page. Obviously as we don&rsquo;t have any pages yet it will be empty, but as we create pages it will fill up.</p>

<p>And here is the list page after we&rsquo;ve added some pages. The first three pages have no <code>parent_id</code> so are root nodes, while the other ones are child nodes.</p>
<div class="imageWrapper">
  <img src="/system/photos/105/original/E162I02.png" width="800" height="492" alt="The pages list after adding some pages." />
</div>

<h3>Creating a Menu Structure</h3>
<p>We&rsquo;ll use this data to create a menu system for our application. We want the root notes to appear in a horizontal menu across the top of each page and the child nodes for the page we&rsquo;re on to appear down the left-hand side. To start we&rsquo;ll have to update our <code>Page</code> model. Although we&rsquo;ve defined a <code>parent_id</code> column we haven&rsquo;t added the functionality to the model to enable a <code>Page</code> to know what its parents and children are. Adding <code>acts_as_tree</code> to the model will do this.</p>
<pre class="ruby">
class Page &lt; ActiveRecord::Base
  acts_as_tree
end
</pre>
<p>The root menu will be the same on every page so we&rsquo;ll put it in the application&rsquo;s layout file.</p>
<pre class="ruby">
&lt;ul id=&quot;menu&quot;&gt;
  &lt;% for page in Page.roots %&gt;
    &lt;li&gt;&lt;%= link_to h(page.name), page %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</pre>
<p>In the code above we call the class method <code>roots</code> on <code>Page</code> which is one of the methods that <code>acts_as_tree</code> provides and which will return an array of all of the pages that have no <code>parent_id</code>. We can then loop through this array to create an unordered list of links. Each link will <code>show</code> the page&rsquo;s name and link to the show action for that page.</p>

<p>A list of bulleted links doesn&rsquo;t look too pretty so we&rsquo;ll add some CSS to style the menu.</p>
<pre class="terminal">
#menu { list-style: none; margin: 0; padding: 0; float: left; width: 100%; }
#menu li { margin: 0 2px; padding: 0; float: left; }
#menu li a { display: block; padding: 4px 8px; text-decoration: none; border: solid 1px black; color: black; background-color: #AEBBE2; }
#menu li a:hover { color: white; background-color: #4A63B8; }
</pre>
<p>We now have a menu at the top of each page that will take us to a root page when we click on a link.</p>
<div class="imageWrapper">
  <img src="/system/photos/106/original/E162I03.png" width="800" height="387" alt="All of the page&rsquo;s fields are shown by default." />
</div>

<h3>Tidying Up The View</h3>
<p>By default the <code>show</code> view lists all of the fields for a model, but we only really want to show the <code>content</code> field. We&rsquo;ll tidy up the view code before we carry on.</p>
<pre class="ruby">
&lt;% title @page.name %&gt;
&lt;%= simple_format(@page.content) %&gt;
&lt;p&gt;
  &lt;%= link_to &quot;Edit&quot;, edit_page_path(@page) %&gt; |
  &lt;%= link_to &quot;Destroy&quot;, @page, :confirm =&gt; &#x27;Are you sure?&#x27;, :method =&gt; :delete %&gt; |
  &lt;%= link_to &quot;View All&quot;, pages_path %&gt;
&lt;/p&gt;
</pre>
<p>The <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/TextHelper.html#M001719">simple_format</a> method will add basic formatting to the content by turning single line breaks into <code>&lt;br/&gt;</code> elements and wrapping text separated by double line breaks in paragraph tags. Note that we&rsquo;ve updated the page&rsquo;s title so that the name is shown rather than the word &ldquo;Page&rdquo;.</p>

<h3>Writing The Sub Menu</h3>
<p>Having tidied the view up a little we can now create the sub menu.  Like the main menu it will be rendered as an unordered list.</p>
<pre class="ruby">
&lt;ul id=&quot;submenu&quot;&gt;
  &lt;% for page in @page.children %&gt;
  &lt;li&gt;&lt;%= link_to h(page.name), page %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</pre>
<p>The difference with this menu is that instead of rendering the all of the root pages, it uses the <code>children</code> method to find the immediate children of the current page.</p>

<p>As we&rsquo;re using the <code>nifty_layout</code> generated code the menu will appear below the page&rsquo;s title, which we don&rsquo;t want. We can pass <code>false</code> as a second argument to the <code>title</code> method to stop it adding the title to the layout file and then manually re-add the title below the menu. The <code>show</code> code will now look like this:</p>
<pre class="ruby">
&lt;% title @page.name, false %&gt;
&lt;ul id=&quot;submenu&quot;&gt;
  &lt;% for page in @page.children %&gt;
  &lt;li&gt;&lt;%= link_to h(page.name), page %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;%= @page.name %&gt;&lt;/h1&gt;
&lt;%= simple_format(@page.content) %&gt;
&lt;p&gt;
  &lt;%= link_to &quot;Edit&quot;, edit_page_path(@page) %&gt; |
  &lt;%= link_to &quot;Destroy&quot;, @page, :confirm =&gt; &#x27;Are you sure?&#x27;, :method =&gt; :delete %&gt; |
  &lt;%= link_to &quot;View All&quot;, pages_path %&gt;
&lt;/p&gt;
</pre>
<p>To finish the submenu off we&rsquo;ll add a dash of CSS so that the links appear on the left of the page.</p>
<pre class="terminal">
#submenu { float: left; list-style: none; border: solid 1px black; padding: 15px 14px; margin: 0 20px 0 0; }
</pre>
<p>When we reload the page now we&rsquo;ll see both menus, with the root pages at the top and the children of the current page on the left.</p>
<div class="imageWrapper">
  <img src="/system/photos/107/original/E162I04.png" width="800" height="305" alt="The sub menu now appears on the left." />
</div>
<p>It looks like we&rsquo;re nearly there, but there&rsquo;s one other thing that needs tidying up. If we visit a page that doesn&rsquo;t have child pages the empty menu will still appear on the left.</p>
<div class="imageWrapper">
  <img src="/system/photos/108/original/E162I05.png" width="800" height="305" alt="The sub menu still appears when it is empty." />
</div>
<p>We can fix this by hiding the menu if the page has no children. A small change to the view code will sort this out.</p>
<pre class="ruby">
&lt;% unless @page.children.empty? %&gt;
&lt;ul id=&quot;submenu&quot;&gt;
  &lt;% for page in @page.children %&gt;
  &lt;li&gt;&lt;%= link_to h(page.name), page %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
&lt;% end %&gt;
</pre>
<h3>Adding a Breadcrumb Trail</h3>
<p>Although we can now navigate down through the hierarchy of pages, there&rsquo;s no way that anyone using our application can see where the page they&rsquo;re on is relative to other pages or navigate back up the tree, except by going straight back to the root nodes. To fix this we&rsquo;ll add a breadcrumb trail to each page. Again, this is done by modifying the <code>show</code> action&rsquo;s view code. We&rsquo;ll add the breadcrumb trail between the main menu and the page&rsquo;s title.</p>
<pre class="ruby">
&lt;div&gt;
&lt;% for page in @page.ancestors.reverse %&gt;
  &lt;%= link_to h(page.name), page %&gt; &amp;gt;
&lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>To find the path back up to the root node we&rsquo;re using the <code>ancestors</code> method, which returns an array. The first element is the page&rsquo;s parent, the second the grandparent and so on until a root page is found. We want our breadcrumb to start at the root so we&rsquo;ve reversed the array and then looped through it creating a link to each page separated by a greater than sign.</p>
<div class="imageWrapper">
  <img src="/system/photos/109/original/E162I06.png" width="800" height="340" alt="Each page now has a breadcrumb control." />
</div>
<p>We now have a useful way of navigating up and down the hierarchy of pages.</p>

<h3>A More General Use</h3>
<p>We&rsquo;ve shown a fairly specific use for <code>acts_as_tree</code> here, and most Rails apps aren&rsquo;t content management systems but a more complex set of controllers and actions. This technique can still be used create a menu system for an application, however. We can still create a <code>Page</code> model, but instead of the content field have a <code>url</code> field that contains the path to that page. The links can then use that <code>url</code> field to direct to the correct page in the application.</p>

<p>If we were using this in a production app it would be a good idea to cache the menus. Menu systems are an ideal candidate for fragment caching as once the menu structure has been defined for your application it will rarely change. Fragment caching was covered back in <a href="http://railscasts.com/episodes/90-fragment-caching">Railscast 90</a>, which is well worth a look for more information.</p>