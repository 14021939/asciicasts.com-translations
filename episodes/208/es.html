<head><base href='http://www.asciicasts.com'></head>

<p>Ya ha sido liberada la segunda versión beta de Rails 3.0 y uno de los cambios más significativos es la forma en la que se gestionan los bloques en las vistas.  En este episodio veremos qué es l que ha cambiado.</p>

<h3>Actualización de Ruby y Rails</h3>

<p>Antes de actualizarnos a la nueva beta de Rails 3 vamos a actualizar primero nuestra versión de Ruby a 1.9.2  En el episodio 200 [<a href="http://railscasts.com/episodes/200-rails-3-beta-and-rvm">verlo</a>, <a href="http://es.asciicasts.com/episodes/200-rails-3-beta-y-rvm">leerlo</a>] vimos cómo utilizar rvm para instalar Ruby 1.9.1 pero esta versión tiene algunos errores y la 1.9.2 parece más robusta (aun cuando sigue estando en desarrollo).</p>

<p>Con rvm tenemos que ejecutar este comando para instalar Ruby 1.9.2:</p>

<pre class="terminal">
rvm install ruby-head
</pre>

<p>Con esto se descargará la última versión de Ruby 1.9.2, que aún está en desarrollo.  Una vez que rvm haya instalado la nueva versión podemos cambiar a ella con</p>

<pre class="terminal">
rvm ruby-head --default
</pre>

<p>Nótese que hemos utilizado la opción <code>--default</code> para que 1.9.2 sea la versión por defecto de Ruby, lo que quiere decir que si abrimos otras ventanas de terminal también tendrán como versión de Ruby la 1.9.2.</p>

<p>La beta 2 de Rails 3 requiere que tengamos RubyGems 1.3.6 así que antes de instalarlo tendremos que hacer</p>

<pre class="terminal">
gem -v
</pre>

<p>para ver qué versión tenemos instalado.  Si tenemos una anterior a la 1.3.6 podemos hacer</p>

<pre class="terminal">
gem update --system
</pre>

<p>Ya podemos instalar Rails 3.0 beta 2 con:</p>

<pre class="terminal">
gem install rails --pre
</pre>

<h3>Actualizando las aplicaciones</h3>

<p>Podemos actualizar cualquier aplicación que hayamos desarrollado con la anterior beta de Rails simplemente cambiando el número de versión que figura en el Gemfile de <code>3.0.0.beta</code> a <code>3.0.0.beta2</code>.</p>

<p class="codeFilePath">/Gemfile</p>
<pre class="ruby">
gem &quot;rails&quot;, &quot;3.0.0.beta2&quot;
</pre>

<p>Tras esto podemos ejecutar <code>bundle install</code> para que se resuelvan todas las dependencias.</p>

<h3>Los cambios en erb</h3>

<p>Hay dos tipos de etiquetas que se usan en los ficheros erb.  Si el código aparece entre etiquetas 
<code>&lt;%= %&gt;</code> en la vista aparecerá lo que devuelva la evaluación del código Ruby insertado entre ellas.  Si omitimos el signo de igualdad el código se interpretará pero su salida será descartada.   Se trata de un concepto muy común en erb que ha sido extendido en Rails 3 para que funcione dentro de bloques.</p>

<p>Esto aparece frecuentemente en los formularios.  Abajo figura una plantilla erb correspondiente al formulario de un modelo <code>Product</code>.</p>


<p class="codeFilePath">/app/views/products/_form.html.erb</p>
<pre class="ruby">
&lt;% form_for @product do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;p&gt;
    &lt;%= f.label :category_id %&gt;&lt;br /&gt;
    &lt;%= f.collection_select :category_id, Category.all, :id, :name %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :name %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :price %&gt;&lt;br /&gt;
    &lt;%= f.text_field :price %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :description %&gt;&lt;br /&gt;
    &lt;%= f.text_area :description %&gt;
  &lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;
</pre>

<p>En la primera línea de este código hemos utilizado <code>form_for</code>, que insertará etiquetas de formulario en la vista rodeando el contenido del bloque... pero en las etiqueta erb no aparece el signo igual, lo que viola la regla de que los bloques erb que devuelven marcado en la vista deberían utilizar <code>&lt;%= %&gt;</code> y ha hecho que sea difícil trabajar dentro de <code>form_for</code> en versiones anteriores de Rails.  A partir de la nueva beta ya podemos utilizar signos de igual como con cualquier otro código erb que genera texto en HTML.</p>

<p class="codeFilePath">/app/views/products/_form.html.erb</p>
<pre class="ruby">
&lt;%= form_for @product do |f| %&gt;
  &lt;!-- rest of form --&gt;
&lt;% end %&gt;
</pre>

<p>Estamos usando el símbolo de igualdad aunque le estemos pasando un bloque a <code>form_for</code> (si bien hay que tener en cuenta que la etiqueta de cierre <code>end</code> no lo lleva) Esto insertará la etiqueta <code>form</Code> y los contenidos del formulario correctamente, y sirve también para arreglar el interior de <code>form_for</code>, como veremos en breve.</p>

<p>Cabría preguntarse cuándo hace falta utilizar el símbolo de igualdad y cuando no.  Echémosle un vistazo a un par de ejemplos empezando por <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/RecordTagHelper.html#M001643">div_for</a>:</p>

<pre class="ruby">
&lt;%= div_for @product do %&gt;

&lt;% end %&gt;
</pre>

<p>En versiones anteriores de Rails no hacía falta usar el símbolo de igualdad pero ahora es necesario porque estamos devolviendo contenido alrededor del bloque (en este caso una etiqueta <code>div</code>).  De hecho la mayoría de los <em>helpers</em> de Rails ahora exigen este símbolo porque siempre escriben algo rodeando el bloque que aceptan.</p>

<p>Sin embargo aún quedan algunos casos en los que no es necesario este símbolo.  Por ejemplo cualquier cosa que utilice el método <code>each</code>:</p>

<pre class="ruby">
&lt;% @comments.each do |c|%&gt;

&lt;% end %&gt;
</pre>

<p>El método <code>each</code> no devuelve nada que queramos sacar en la vista, por tanto no se debe utilizar el símbolo de igualdad dado que lo que devuelve este método no se visualiza.</p>

<p>Otro ejemplo es el método <code>content_for</code>.</p>

<pre class="ruby">
&lt;% content_for :side do %&gt;

&lt;% end %&gt;
</pre>

<p>Aquí tampoco se usa el símbolo de igualdad porque la llamada a <code>content_for</code> guarda el contenido del bloque en una variable que se utilizará más tarde.  Nada se muestra en la vista, por tanto no hay que usar el símbolo de igualdad.</p>

<p>Por desgracia hay una excepción a esta regla: el método <code>cache</code>.  Idealmente, <code>cache</code> debería utilizar un símbolo de igualdad porque podría devolver cierto contenido en la vista pero no lo hace debido a su funcionamiento interno.</p>

<pre class="ruby">
&lt;% cache do %&gt;

&lt;% end %&gt;
</pre>

<h3>Uso de bloques en métodos <em>helper</em></h3>

<p>Estos cambios pueden parecer un poco confusos al principio pero una vez que nos acostumbremos cobrarán más sentido.  El motivo principal de este cambio es que con él se reorganiza el código interno.  En el <a href="http://railscasts.com/episodes/40-blocks-in-view">episodio 40</a> veíamos cómo utilizar bloques en las vistas en las versiones anteriores de Rails.  Era necesario utilizar el método <code>concat</code> para poder poner texto por delante o por detrás del bloque, lo que hacía un poco díficil el trabajo.</p>

<pre class="ruby">
def admin_area(&amp;block)
  concat(&#x27;&lt;div class=&quot;admin&quot;&gt;&#x27;, block.binding)
  block.call
  concat(&quot;&lt;/div&gt;&quot;, block.binding)
end
</pre>

<p>Vamos a ver, como demostración de que como es mucho más fácil utilizar ahora bloques en los métodos, una sencilla aplicación de tienda que debe mostrar un número de enlaces pero que sólo serán visibles a los administradores.</p>

<div class="imageWrapper">
  <img src="/system/photos/358/original/E208I01.png" width="800" height="339" alt="La ficha de un producto mostrando los enlaces del administrador."/>
</div>

<p>Queremos que los enlaces &ldquo;Edit&rdquo;, &ldquo;Destroy&rdquo; y &ldquo;View All&rdquo; sólo sean visibles por el administrador y también queremos rodear los enlaces de una etiqueta <code>div</code>.  Los enlaces se crearán en la vista con el siguiente código:</p>

<p class="codeFilePath">/app/views/products/show.html.erb</p>
<pre class="ruby">
&lt;p&gt;
  &lt;%= link_to &quot;Edit&quot;, edit_product_path(@product) %&gt; | 
  &lt;%= link_to &quot;Destroy&quot;, @product, :confirm =&gt; &quot;Are you sure?&quot;, :method =&gt; :delete %&gt; | 
  &lt;%= link_to &quot;View All&quot;, products_path %&gt;
&lt;/p&gt;
</pre>

<p>Vamos a reemplazar las etiquetas del párrafo con un nuevo método <em>helper</em> que llamaremos <code>admin_area</code>:</p>

<p class="codeFilePath">/app/views/products/show.html.erb</p>
<pre class="ruby">
&lt;%= admin_area do %&gt;
  &lt;%= link_to &quot;Edit&quot;, edit_product_path(@product) %&gt; | 
  &lt;%= link_to &quot;Destroy&quot;, @product, :confirm =&gt; &quot;Are you sure?&quot;, :method =&gt; :delete %&gt; | 
  &lt;%= link_to &quot;View All&quot;, products_path %&gt;
&lt;% end %&gt;
</pre>

<p>Este método <code>admin_area</code> añadirá la etiqueta <code>div</code> y mostrará u ocultará los enlaces según el usuario registrado sea o no administrador.  Obsérvese que debido a que nuestro método envía salida a la vista hemos utilizado un símbolo de igualdad en la etiqueta de apertura.</p>

<p>Vamos a definir el método en <code>application_helper</code>  Lo mejor de esta nueva forma de trabajar con bloques en los <em>helpers</em> es que se comporta exactamente como sería de esperar, de forma que si el método sólo devuelve una cadena, eso es lo que se mostrará en la vista.</p>

<p class="codeFilePath">/app/helpers/application_helper.rb</p>
<pre class="ruby">
module ApplicationHelper
  def admin_area(&amp;block)
    &quot;OH HAI!&quot;
  end
end
</pre>

<p>Si ahora recargamos la página el contenido del bloque será reemplazado por la cadena devuelta por el método <code>admin_area</code>.  Los enlaces no se muestran dado que no estamos ejecutando el bloque en el método.</p>

<div class="imageWrapper">
  <img src="/system/photos/359/original/E208I02.png" width="800" height="339" alt="The contents of the block are replaced by the string."/>
</div>

<p>Para ejecutar el bloque y devolver el contenido tenemos que llamar a un nuevo método
denominado <code>with_output_buffer</code> y pasarle el bloque. Esto hará que se evalúe el bloque
en un <em>buffer</em> distinto de salida de forma que el contenido no se muestre directamente
en la vista.  Podemos asignar dicha salida a una variable y luego hacer lo que queramos con ella.  
En este caso queremos rodear el contenido de un <code>div</code> con una <code>class</code> llamada
<code>admin</code> por lo que vamos a modificar nuestro método <code>admin_area</code> asÍ:</p>

<p class="codeFilePath">/app/helpers/application_helper.rb</p>
<pre class="ruby">
def admin_area(&amp;block)
  content = with_output_buffer(&amp;block)
  content_tag(:div, content, :class =&gt; &#x27;admin&#x27;)
end
</pre>

<p>Cuando recarguemos la página veremos los enlaces de administración rodeados de un <code>div</code>. 
Como y ahemos creado un estilo para la clase <code>admin</code> en la hoja de estilos de la 
aplicación, dichos estilos se aplicarán sobre esta capa.</p


<div class="imageWrapper">
  <img src="/system/photos/360/original/E208I03.png" width="800" height="339" alt="El bloque queda rodeado de una elemento div."/>
</div>

<p>Examinando el código fuente de la página veremos el <code>div</code> rodeando los enlaces.</p>

<pre class="html">
&lt;div class=&quot;admin&quot;&gt;
  &lt;a href=&quot;/products/1/edit&quot;&gt;Edit&lt;/a&gt; | 
  &lt;a href=&quot;/products/1&quot; data-confirm=&quot;Are you sure?&quot; data-method=&quot;delete&quot; rel=&quot;nofollow&quot;&gt;Destroy&lt;/a&gt; | 
  &lt;a href=&quot;/products&quot;&gt;View All&lt;/a&gt;
&lt;/div&gt;
</pre>

<p>Por tanto podemos usar el método <code>with_output_buffer</code> para obtener el contenido evaluado de un bloque en una vista.  Dicho esto, el código que hemos escrito en nuestro <em>helper</em> no era más que un ejemplo sencillo y de hecho existe una forma más eficiente de hacer lo mismo.</p>

<p>El método <code>content_tag</code> puede recibir un bloque como argumento, lo que significa que podemos reescribir nuestro <em>helper</em> así:</p>

<p class="codeFilePath">/app/helpers/application_helper.rb</p>
<pre class="ruby">
def admin_area(&amp;block)
  content_tag(:div, :class =&gt; &#x27;admin&#x27;, &amp;block)
end
</pre>

<p>Por supuesto para que este método sea totalmente funcional querremos mostrar la salida sólo si el usuario es administrador, lo que podemos conseguir utilizando un método que devuelva un valor booleano.</p>

<p class="codeFilePath">/app/helpers/application_helper.rb</p>
<pre class="ruby">
def admin_area(&amp;block)
  content_tag(:div, :class =&gt; &#x27;admin&#x27;, &amp;block) if admin?
end
</pre>

<p>Eso es todo por este episodio.  Es posible que tardemos un poco en acostumbrarnos a utilizar signos de igualdad con bloques en nuestras vistas, pero a largo plazo veremos que tiene más sentido, porque estos bloques devuelven contenido.  Y además esto redunda en una mejora de la implementación del código de las vistas en Rails.</p>

<p>Por último, un truco final.  En versiones anteriores de Rails podíamos añadir un símbolo de sustracción al principio o final de una etiqueta erb para eliminar los espacios en blanco, para que el marcado quedase un poco más limpio.  En Rails 3 esto ya no es necesario y si una etiqueta erb no devuelve salida será automáticamente eliminada, por lo que dicha etiqueta no generará espacios en blanco innecesarios.</p>

