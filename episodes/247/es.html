<p>En este episodio vamos a trabajar con una aplicación Rails sencillita  llamada  &ldquo;Lista de la Compra&rdquo;, que almacena una serie de elementos.  Para usarla tan sólo tenemos que teclear el nombre del ítem y pulsar en el botón &ldquo;Add Item&rdquo;.  A continuación la página se recargará y mostrará el elemento recién añadido en la lista.</p>

<div class="imageWrapper">
  <img src="/system/photos/541/original/E247I01.png" width="800" height="289" alt="La aplicación de lista de la compra."/>
</div>

<p>Si bien la aplicación funciona correctamente cuando estamos conectados a la red, si la utilizamos en un teléfono móvil no siempre tendremos cobertura y por tanto no podremos acceder a la lista de la compra.  Sería útil que la aplicación funcionase sin conexión, y esto es lo que aprenderemos en este episodio.</p>

<h3>Introducción al manifiesto de caché</h3>

<p>Demostraremos nuestra aplicación en un navegador de escritorio pero por lo general sólo querremos que esté disponible sin conexión la versión móvil del sitio.  Ya vimos en el episodio 199  [<a href="http://railscasts.com/episodes/199-mobile-devices">verlo</a>, <a href="http://es.asciicasts.com/episodes/199-dispositivos-moviles">leerlo</a>] cómo hacer una versión específica para dispositivos móviles.  Si seguimos este enfoque conseguiremos que la versión móvil sea más sencilla, y eso hará que sea más fácil hacer que esté disponible sin conexión.</p>

<p>Para que la aplicación funcione sin conexión a la red utilizaremos una técnica de HTML5 basada en el manifiesto de caché.  El sitio   <a href="http://diveintohtml5.org/">Dive Into HTML5</a>, que es una de las mejores fuentes de información sobre HTML5, tiene una página dedicada a las <a href="http://diveintohtml5.org/offline.html">aplicaciones sin conexión (en inglés)</a> que merece la pena leer para ponernos al día en este tema.</p>

<p>Lo primero es crear un <a href="http://diveintohtml5.org/offline.html#manifest">manifiesto de caché</a>, y existe una gema llamada <a href="https://github.com/wycats/rack-offline">rack-offline</a> que nos puede ser de ayuda.  La forma más fácil de usarla es añadir la siguiente ruta a nuestra aplicación.</p>

<pre class="ruby">match &quot;/application.manifest&quot; =&gt; Rails::Offline</pre>

<p>La ruta apunta a una aplicación Rack llamada <code>Rails::Offline</code>.  Si se visita <code>/application.manifest</code> se generará el manifiesto de caché con ciertos valores por defecto.  Por supuesto tenemos que añadir una referencia a esta gema en el fichero <code>Gemfile</code> de nuestra aplicación, y luego ejecutar la orden <code>bundle</code> para asegurar su instalación.</p>

<p class="codeFilePat">/Gemfile</p>
<pre class="ruby">gem &#x27;rack-offline&#x27;</pre>

<p>A continuación añadiremos la ruta a <code>application.manifest</code>.</p>


<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">match &quot;/application.manifest&quot; =&gt; Rails::Offline</pre>

<p>Si visitamos con el navegador <a href="http://localhost:3000/application.manifest"><code>http://localhost:3000/application.manifest</code></a> veremos que nos devuelve un fichero de manifiesto de caché.  Dicho fichero contiene una lista de los archivos que deben ser descargados para que la aplicación pueda funcionar sin conexión.  La gema rack-offline añadirá, por defecto, todos los archivos HTML, CSS y JavaScript del directorio <code>/public</code>.  Esto sólo funcionará con aplicaciones pequeñas pero se puede personalizar para elegir los archivos que se tendrán que incluir en el manifiesto, se describen los detalles para hacerlo en la  <a href="https://github.com/wycats/rack-offline#readme">documentacion de rack-offline</a>.</p>

<div class="imageWrapper">
  <img src="/system/photos/542/original/E247I02.png" width="800" height="286" alt="El contenido del manifiesto de caché."/>
</div>

<p>Nótese que hay una suma de control al comienzo del manifiesto.  Con esto Rack-offline puede identificar revisiones específicas del manifiesto de caché.  Mientras la aplicación esté en modo de desarrollo la suma cambiará cada vez que carguemos la página, pero en producción sólo cambiará cuando uno de los archivos listados en el manifiesto cambie lo que indica al navegador que debe descargar otra vez los archivos.</p>

<p>Aunque ya tenemos un manifiesto de caché todavía tenemos que decirle a la aplicación que lo utilice.  Esto se hace poniendo el atributo <code>manifest</code>  a la etiqueta HTML del fichero de <em>layout</em> de la aplicación.</p>

<p class="codeFilePath">/app/views/layouts/application.html.erb</p>
<pre class="javascript">&lt;html manifest=&quot;/application.manifest&quot;&gt;</pre>

<p>El atributo <code>manifest</code> hace que se descarguen los archivos enumerados en el manifiesto de caché cada vez que alguien cargue una página de esta aplicación, así como la propia página de forma que esté disponible cuando no exista conexión.</p>

<p>Si ahora visitamos la página del listado de nuestra aplicación se descargarán todos los ficheros anotados en el manifiesto, así como la propia página que contiene el listado.  Esto se puede comprobar visitando la página y luego parando el servidor Rails de la aplicación.  Si después abrimos una ventana del navegador y visitamos   <a href="http://localhost:3000/items"><code>http://localhost:3000/items</code></a> veremos que la página sigue ahí incluso con el servidor parado, porque está siendo servida desde la caché.</p>

<p>Pero todavía tenemos un problema.  Si recargamos la página veremos que se pierde la hoja de estilos.</p>

<div class="imageWrapper">
  <img src="/system/photos/543/original/E247I03.png" width="800" height="286" alt="Al refrescar la página se pierden los estilos."/>
</div>

<p>De hecho el navegador no está logrando cargar las hojas de estilos ni ninguno de los ficheros JavaScript de la aplicación.  El motivo son los sellos de tiempo que Rails añade a la URL de estos archivos.</p>

<div class="imageWrapper">
  <img src="/system/photos/544/original/E247I04.png" width="801" height="203" alt="El navegador intenta descargar los archivos del servidor."/>
</div>

<p>Estos sellos hacen que el navegador considere que los archivos son distintos de los que han sido declarados en el manifiesto de caché, y por tanto los intenta cargar de nuevo del servidor.  Se puede solucionar este problema configurando una variable de entorno que elimina los sellos de tiempo en nuestra aplicación añadiendo la siguiente línea debajo de  <code>/config/application.rb</code>.</p>

<p class="codeFilePath">/config/application.rb</p>
<pre class="ruby">ENV[&quot;RAILS_ASSET_ID&quot;] = &quot;&quot;</pre>

<p>Para que esto funcione tenemos que volver a arrancar el servidor y visitar otra vez la página, recargándola una o dos veces para asegurarnos de que todo ha sido cargado y cacheado correctamente.  Una vez hecho esto podremos parar de nuevo el servidor y veremos que la aplicación funcionará correctamente sin conexión, cargándose correctamente los ficheros CSS y JavaScript, dado que no tendrán sellos de tiempo tras los nombres.</p> 

<h3>Problemas con la caché</h3>

<p>Durante lo que queda de episodio tendremos el servidor arrancado para simular que estamos navegando con conexión y así ver algunos problemas potenciales.  Lo primero de lo que nos daremos cuenta es de que los cambios que hacemos en nuestra aplicación no surten efecto inmediatamente.  Por ejemplo, supongamos que queremos cambiar el texto en el botón  &ldquo;Add Item&rdquo; para que sea  &ldquo;Add&rdquo;. Se trata de un cambio fácil, tan sólo tenemos que cambiar el texto en el código de la vista.</p>

<p class="codeFilePath">/app/views/items/index.html.erb</p>
<pre class="ruby">&lt;%= form_for Item.new do |f| %&gt;
 &lt;%= f.text_field :name %&gt;
 &lt;%= f.submit &quot;Add&quot; %&gt;
&lt;% end %&gt;</pre>

<p>Al guardar este archivo y recargar la página esperaríamos que el texto del botón cambiase, pero no lo hace.  El motivo es que el navegador devuelve la versión cacheada de la página: no pregunta si el servidor está levantado sino que devuelve de inmediato lo que tiene en caché.  Sin embargo en segundo plano comprobará el manifiesto de caché para ver si ha habido cambios y entonces sí que descargará los ficheros modificados.  Si luego volvemos a cargar la página por segunda vez veremos que el texto del botón sí que cambia porque para entonces el navegador ya habrá detectado los cambios y los habrá cacheado.</p>

<div class="imageWrapper">
  <img src="/system/photos/545/original/E247I05.png" width="800" height="286" alt="Al no tener los sellos de tiempo los ficheros cacheados siempre se sirven desde la caché."/>
</div>

<p>Esto quiere decir que para que los cambios hagan efecto en desarrollo debemos acostumbrarnos a recargar la página un par de veces cada vez que hagamos un cambio.</p>

<p>Se puede presentar otro problema cuando la caché apunte a un fichero que ya no existe o que tiene otro nombre.  Por ejemplo si eliminásemos el archivo <code>422.html</code> del directorio <code>/public/</code> el manifiesto dejaría de servir.  Para demostrarlo, cambiemos otra vez el texto del botón para que sea  &ldquo;Add Another Item&rdquo;.</p>

<p class="codeFilePath">/app/views/items/index.html.erb</p>
<pre class="ruby">&lt;%= form_for Item.new do |f| %&gt;
 &lt;%= f.text_field :name %&gt;
 &lt;%= f.submit &quot;Add Another Item&quot; %&gt;
&lt;% end %&gt;</pre>

<p>Ya podemos recargar la página todas las veces que queramos que el texto del botón no cambiará, porque el manifiesto aborta al llegar al fichero <code>422.html</code> que hemos eliminado, por lo que nunca actualiza la caché de la página de lista de la compra.  No veremos los cambios nunca incluso aunque el servidor continúe activo.</p>

<p>Es difícil depurar este tipo de problemas porque no hay ningún síntoma de que se ha producido este error con el manifiesto de caché.  Para ayudarnos con esto podemos añadir código JavaScript que esté pendiente del evento de error en el objeto <code>applicationCache</code> y detecte cuando se produzcan estos errores.</p>

<p>Como en la aplicación estamos usando jQuery podemos añadir esta detección de errores con el siguiente código en nuestro fichero <code>application.js</code>.</p>


<p class="codeFilePath">/public/javascripts/application.js</p>
<pre class="javascript">$(function () {
  $(windows.applicationCache.bind(&#x27;error&#x27;, function () {
    alert(&#x27;There was an error when loading the cache manifest.&#x27;);
  }))
})</pre>

<p>Esta alerta no funcionará con la aplicación en el estado en que está porque al tener el manifiesto roto no recargará el nuevo fichero <code>application.js</code> pero la alerta de JavaScript saltará la próxima vez que tengamos un problema parecido, y así sabremos que hay algo mal.</p>

<p>Para arreglar ahora el manifiesto de caché tan sólo tenemos que reiniciar el servidor web para que el fichero del manifiesto se actualice automáticamente.  Con esto volverá el comportamiento anterior de la aplicación y cuando hagamos cambios siempre los veremos tras recargar un par de veces la página.</p>

<p>La caché de contenidos puede presentar problemas que sólo detectaremos en producción.  Si añadimos un elemento a la lista de la compra el nuevo elemento será añadido a la base de datos.  La página de la lista se actualiza dinámicamente desde la base de datos y veremos que aparecen todos los elementos.  En modo de desarrollo todo parece funcionar: el elemento se añade a la lista y sigue ahí cuando recargamos la página.</p>

<div class="imageWrapper">
  <img src="/system/photos/546/original/E247I06.png" width="802" height="306" alt="Podemos añadir elementos a la lista."/>
</div>

<p>Pero ¿y si intentamos hacer esto en producción?  Para simularlo haremos que <code>cache_classes</code> sea <code>true</code> en <code>development.rb</code> (si usamos las técnicas de este capítulo en nuestras aplicaciones tendremos que probar exhaustivamente en modo de producción)</p>

<p class="codeFilePath">/config/development.rb</p>
<pre class="ruby">config.cache_classes = true</pre>

<p>Tenemos que reiniciar el servidor para que coja este cambio.  Una vez que lo tengamos, añadiremos otro elemento a la lista, por ejemplo  &ldquo;chunky bacon&rdquo;.</p>

<div class="imageWrapper">
  <img src="/system/photos/547/original/E247I07.png" width="802" height="311" alt="En producción parece que también podemos añadir elementos."/>
</div>

<p>El elemento que acabamos de añadir aparece porque acabamos de hacer una petición POST pero desaparecerá si recargamos la página: se vuelve a mostrar la versión antigua cacheada de la página, nuevamente por culpa del manifiesto de caché.  Ahora que tenemos la aplicación en producción el manifiesto no cambia, por lo que el navegador desconoce que la página ha sido modificada y vuelve a servir la versión antigua.  Este problema sólo ocurre en producción, no en desarrollo.</p>

<p>La cuestión clave es: ¿cómo controlamos los contenidos dinámicos?  Es un tema más complejo de lo que podría parecer en un principio, el servidor no puede actualizar dinámicamente la página porque se encuentra cacheada por el navegador.  Lo que podemos hacer es actualizar su contenido por JavaScript, y esto es lo que haremos en el siguiente episodio.</p>

