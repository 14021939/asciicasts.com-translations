<p>Un po' di episodi fa <a href="http://asciicasts.com/episodes/188-declarative-authorization">abbiamo trattato Declarive Authorization</a>. Anche se si tratta di un ottimo plugin per l&rsquo;autorizzazione in applicazioni Rails, potrebbe rivelarsi un po&rsquo; troppo pesante per i siti pi&ugrave, semplici. Dopo avere scritto il <a href="http://railscasts.com/episodes/188-declarative-authorization">Railscast su Declarative Authorization</a>, Ryan Bates ha cercato una soluzione alternativa per lo stesso problema e, non trovandone una che soddisfasse le sue aspettative, ha deciso di scriverne una per conto suo, <a href="http://github.com/ryanb/cancan">CanCan</a>. CanCan &egrave; un semplice plugin per l&rsquo;autorizzazione in cui Ryan ha cercato di mantenere ogni cosa il pi&ugrave; semplice possibile mentre la scriveva. Diamogli un&rsquo;occhiata.</p>

<p>In questo episodio lavoreremo con la solita semplice applicazione di blogging usata anche nell&rsquo;episodio relativo a Declarative Authorization. L&rsquo;applicazione ha una serie di articoli, ciascuno dei quali appartiene ad un utente e ciascun articolo pu&ograve; avere molti commenti associati ad esso.</p>

<div class="imageWrapper">
  <img src="/system/photos/264/original/E192I01.png" width="815" height="606" alt="La pagina dell&rsquo;articolo nella nostra applicazione."/>
</div>

<p>Nello screenshot di sopra si noti che, anche se non c&rsquo;&egrave; alcun utente autenticato, i link alla modifica e alla cancellazione degli articoli e dei commenti sono visibili. Vogliamo usare l&rsquo;autorizzazione per gestire ci&ograve; che ciascun utente ha il diritto di compiere sul sito. Abbiamo gi&agrave; un meccanismo di autenticazione nella nostra applicazione, che permette agli utenti di registrarsi e accedere al sito ed abbiamo a suo tempo usato Authlogic per realizzare queste logiche, anche se alla fine una qualunque soluzione per l&rsquo;autenticazione andrebbe bene.</p>

<p>Nella pagina di registrazione, abbiamo una serie di checkbox per permettere ad un utente di scegliere il ruolo al quale questi vogliono essere associati. Ad un amministratore sar&agrave; permesso tutto, ad un moderatore la sola modifica dei commenti di chiunque e ad un autore la creazione di articoli e l&rsquo;aggiornamento dei proprio. Gli utenti che non appartengono ad alcun ruolo possono solamente creare nuovi commenti e modificare quelli scritti da loro:</p>

<div class="imageWrapper">
  <img src="/system/photos/265/original/E192I02.png" width="800" height="510" alt="La pagina di registrazione che mostra i checkbox dei ruoli."/>
</div>

<h3>Installazione di CanCan</h3>

<p>CanCan &egrave; distribuito come gem. Per aggiungerlo alla nostra applicazione dobbiamo aggiungere la seguente linea nel blocco <code>Rails::Initializer.run</code> del nostro file <code>/config/environment.rb</code>:</p>

<pre class="ruby">
config.gem &quot;cancan&quot;
</pre>

<p>Possiamo assicurarci che il gem sia installato, lanciando:</p>

<pre class="terminal">sudo rake gems:install</pre>

<p>Se avete gi&agrave; installato CanCan in precedenza, dovete sincerarvi di essere aggiornati all&rsquo;ultima versione, dal momento che ci sono alcune nuove funzionalit&agrave; disponibili solo a partire dalla versione 1.0.0.</p> 

<h3>Utilizzo di CanCan</h3>

<p>Per usare CanCan dobbiamo creare una nuova classe chiamata <code>Ability</code>, che metteremo nella cartella <code>/app/models</code>. La classe deve includere il module <code>CanCan::Ability</code> oltre che un metodo <code>initialize</code> che prende un oggetto user come parametro. E&rsquo; proprio in questo metodo che definiamo i diritti per ogni tipo di utente:</p>

<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)

  end
end
</pre>

<p>I diritti sono definiti attraverso il metodo a tre lettere che &egrave; il cuore di CanCan. Questo metodo accetta due parametri: il primo &egrave; la action che vogliamo eseguire ed il secondo &egrave; la classe di modello a cui si applica la action. In alternativa, per applicare una action a tutti i modelli, possiamo passare <code>:all</code>. Se vogliamo che tutti gli utenti possano solamente leggere tutti i modelli, possiamo scrivere questo:</p>

<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    can :read, :all
  end
end
</pre>

<p>Per come abbiamo impostato ora i diritti, nessuno pu&ograve; modificare o cancellare articoli o commenti, tuttavia ci sono ancora i link alle action <code>edit</code> e <code>destroy</code> nella pagina di ciascun articolo. Nel codice della vista relativa alla action <code>show</code> dell&rsquo;articolo possiamo usare <code>can?</code> (notate il punto interrogativo) per stabilire se l&rsquo;utente corrente sia autorizzato ad eseguire la action alla quale ciascun link &egrave; associato. Mentre il metodo <code>can</code> determina i diritti, il metodo <code>can?</code> &egrave; un metodo booleano che indica se l&rsquo;utente corrente abbia o meno tali diritti. Come <code>can</code>, <code>can?</code> accetta due parametri, una action e un modello, in questo caso un <code>Article</code>. Usiamo <code>can?</code> nella cista affinch&egrave; i link edit e destroy siano nascosti a meno che l&rsquo;utente corrente non abbia un opportuno diritto. Per fare ci&ograve;, racchiudiamo i link degli articoli in una guardia <code>if</code>, che li mostra solo se l&rsquo;utente corrente pu&ograve; intraprendere l&rsquo;opportuna action sull&rsquo;articolo:</p>

<pre class="ruby">
&lt;p&gt;
  &lt;% if can? :update, @article %&gt;
    &lt;%= link_to &quot;Edit&quot;, edit_article_path(@article) %&gt; |
  &lt;% end %&gt;
  &lt;% if can? :destroy, @article %&gt;
    &lt;%= link_to &quot;Destroy&quot;, @article, :method =&gt; :delete, :confirm =&gt; &quot;Are you sure?&quot; %&gt; |
  &lt;% end %&gt;
  &lt;%= link_to &quot;Back to Articles&quot;, articles_path %&gt;
&lt;/p&gt;
</pre>

<p>Un po&rsquo; pi&ugrave; in basso nella stessa vista, facciamo una modifica analoga per ciascun link di commento:</p>

<pre class="ruby">
&lt;p&gt;
  &lt;% if can? :update, comment %&gt;
    &lt;%= link_to &quot;Edit&quot;, edit_comment_path(comment) %&gt; |
  &lt;% end %&gt;
  &lt;% if can? :destroy, comment %&gt;
    &lt;%= link_to &quot;Destroy&quot;, comment, :method =&gt; :delete, :confirm =&gt; &quot;Are you sure?&quot; %&gt;
  &lt;% end %&gt;
&lt;/p&gt;
</pre>

<p>Possiamo ora caricare la pagina degli articoli e vedere come i link edit e delete per gli articoli siano scomparsi, dal momento che non abbiamo i diritti adeguati alle azioni di modifica o cancellazione:</p>

<div class="imageWrapper">
  <img src="/system/photos/266/original/E192I03.png" width="815" height="416" alt="I link sono ora nascosti."/>
</div>

<h3>Proteggere i controller</h3>

<p>Anche se abbiamo rimosso i link per la modifica degli articoli, e dei commenti, le action di per s&egrave; sono ancora disponibili sul controller e se vengono visitate direttamente, funzionano. Per questa ragione, occorre che bonifichiamo anche il codice dei controller, oltre che le viste, in modo che gli utenti possano avere accesso esclusivamente ad action per le quali sono autorizzati. Ci sono due modi per fare tutto questo in CanCan. Il primo lavora a livello di action: ci avvarremo della action edit dell&rsquo;<code>ArticleController</code> per mostrarne un esempio di uso:</p>

<pre class="terminal">
def edit
  @article = Article.find(params[:id])
  unauthorized! if cannot? :edit, @article
end
</pre>

<p>Per interrompere l&rsquo;esecuzione della action chiamiamo il metodo <code>unauthorized!</code> che solleva un&rsquo;eccezione. Ovviamente vogliamo che questa eccezione sia lanciata solo se l&rsquo;utente non possiede i diritti adeguati. Per verificare ci&ograve;, possiamo usare il solito metodo <code>can?</code> usato gi&agrave; nella vista o, visto che ci siamo, il metodo <code>cannot?</code>.</p>

<p>Se proviamo ad accedere direttamente alla action edit ora, verremo fermati da un errore (l&rsquo;eccezione):</p>

<div class="imageWrapper">
  <img src="/system/photos/267/original/E192I04.png" width="815" height="416" alt="Viene sollevata una eccezione se si tenta di accedere direttamente ad una action senza averne il diritto."/>
</div>

<p>Possiamo replicare questa logica fra tutte le action dei nostri controller, ma per fortuna stiamo usando la convenzione RESTful, per cui ci viene fornito un modo molto pi&ugrave; semplice per fare la stessa cosa. In cima al controller possiamo infatti invocare la <code>load_and_authorize_resource</code>, che caricher&agrave; e autorizzer&agrave; l&rsquo;opportuna risorsa in una before filter. Dal momento che questo metodo carica la risorsa necessaria per noi, basandosi sulla action, possiamo togliere le linee di codice che impostano la variabile di istanza in ogni action (in questo caso <code>@article</code>) rendendo il codice del nostro <code>ArticlesController</code> simile a questo:</p>

<pre class="ruby">
class ArticlesController &lt; ApplicationController

  load_and_authorize_resource

  def index
    @articles = Article.all
  end

  def show
    @comment = Comment.new(:article =&gt; @article)
  end

  def new
  end

  def create
    @article.user = current_user
    if @article.save
      flash[:notice] = &quot;Successfully created article.&quot;
      redirect_to @article
    else
      render :action =&gt; &#x27;new&#x27;
    end
  end

  def edit
  end

  def update
    if @article.update_attributes(params[:article])
      flash[:notice] = &quot;Successfully updated article.&quot;
      redirect_to @article
    else
      render :action =&gt; &#x27;edit&#x27;
    end
  end

  def destroy
    @article.destroy
    flash[:notice] = &quot;Successfully destroyed article.&quot;
    redirect_to articles_url
  end
end
</pre>

<p>Sistemata questa cosa, gli utenti non potranno creare, modificare o cancellare alcun articolo.</p>

<p>Ci occorre fare modifiche simili anche al <code>CommentsController</code> per limitare l&rsquo;accesso anche alle sue action. Nuovamente, usiamo <code>load_and_authorize_resources</code> per caricare la risorsa <code>Comment</code> e verificare i diritti per questa. Se <code>Comment</code> fosse una nested resource sotto ad <code>Article</code> negli instradamenti, potremmo usare <code>:nested</code> con <code>load_and_authorize_resources</code> per caricare i commenti attraverso la risorsa <code>Article</code>:/p>

<pre class="ruby">
load_and_authorize_resource :nested =&gt; :article
</pre>

<p>In questo caso, comunque, non usiamo l&rsquo;innestamento, per cui non abbiamo bisogno di fare cos&igrave;.</p>

<h3>Aggiunta dei diritti (Abilities)</h3>

<p>Ora che la nostra applicazione &egrave; sicura, possiamo cominciare a definire i diritti che ciascun ruolo comporta. Ci&ograve; viene fatto ritornando alla classe <code>Ability</code> che abbiamo creato prima. I diritti che definiamo nel metodo <code>initialize</code> verranno riflessi su tutta la nostra applicazione:</p>

<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    can :read, :all
  end
end
</pre>

<p>Passiamo l&rsquo;utente corrente al metodo <code>initialize</code>, in modo tale da poter cambiare i diritti a seconda di chi sia l&rsquo;utente autenticato correntemente. Cominciamo con gli utenti di ruolo amministrativo, che dovrebbero poter fare tutto.</p>

<p>The user passed to <code>initialize</code> can be an object of any type which means that the authentication is completely decoupled from the authorization. What defines a user as, say, an administrator entirely depends on the authentication system used. We might, for example, have an <code>admin?</code> boolean field in our <code>User</code> model. In our application a user can have many roles and we&rsquo;ll have a <code>role?</code> method to tell us if a user is a member of a role. We&rsquo;ll use that method to set the abilities.</p>
<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    if user.role? :admin
      can :manage, :all
    else
      can :read, :all
    end
  end
end
</pre>
<p>Our code now checks to see if the current user is an admin and if so allows them to manage all models. Passing <code>:manage</code> as an action means that the user can perform all actions on a model.</p>

<p>We still need to define the <code>role?</code> method in the <code>User</code> model. We&rsquo;ve set up in the roles here in the same way we did in Episode 189 [<a href="http://railscasts.com/episodes/189-embedded-association">watch</a>, <a href="http://asciicasts.com/episodes/189-embedded-association">read</a>] but it doesn&rsquo;t matter how you set up your roles as long as you can determine which role or roles a user belongs to.</p>
<pre class="ruby">
class User &lt; ActiveRecord::Base
  acts_as_authentic
  has_many :articles
  has_many :comments

  named_scope :with_role, lambda { |role| {:conditions =&gt; &quot;roles_mask &amp; #{2**ROLES.index(role.to_s)} &gt; 0 &quot;} }

  ROLES = %w[admin moderator author editor]

  def roles=(roles)
    self.roles_mask = (roles &amp; ROLES).map { |r| 2**ROLES.index(r) }.sum
  end

  def roles
    ROLES.reject { |r| ((roles_mask || 0) &amp; 2**ROLES.index(r)).zero? }
  end

  def role?
    roles.include? role.to_s
  end

end
</pre>
<p>The <code>role?</code> method we&rsquo;ve added here checks that the role passed is included in the user&rsquo;s roles.</p>

<p>Back in the <code>Ability</code> class we need to make one more change. In <code>initialize</code> we&rsquo;re checking to see if the user belongs to a role but for guest users, i.e. users who have not yet logged in, <code>user</code> will be <code>nil</code>. We could check for <code>nil</code> before trying to check the user&rsquo;s role but instead we&rsquo;ll create a guest user if the user passed in is <code>nil</code>. This way we can still call methods like <code>role?</code> for users who have not yet set up an account.</p>
<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new # Guest user
    if user.role? :admin
      can :manage, :all
    else
      can :read, :all
    end
  end
end
</pre>

<p>If we go back to our application again we still won&rsquo;t be able to edit or destroy comments, but if we log in as a user in the admin role then the links will be shown.</p>

<div class="imageWrapper">
  <img src="/system/photos/268/original/E192I05.png" width="816" height="458" alt="The links are visible again for administrators."/>
</div>

<p>Having got authorization working for administrators we now need to set up the abilities for the other roles. We&rsquo;ll start with guest users, those who have no roles assigned to them. These should be able to create comments and update comments that they have written. To do this we&rsquo;ll modify our <code>Ability</code> class thus:</p>
<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new

    if user.role? :admin
      can :manage, :all
    else
      can :read, :all
      can :create, Comment
      can :update, Comment do |comment|
        comment.try(:user) == user
      end
    end
  end
end
</pre>
<p>Writing the code to enable guest users to create comments is straightforward but the update code is a little trickier as users should only be able to update comments they have written. To do this we pass can a block which will pass in the instance of the model we&rsquo;re checking. The block should return <code>true</code> or <code>false</code> depending on whether the action should be allowed so in the block we&rsquo;ll check that the comment&rsquo;s user is the current user. There&rsquo;s a possibility that the comment might be <code>nil</code> so we&rsquo;ll use Rails&rsquo; <code>try</code> method to read the user attribute so that <code>nil</code> is returned if the comment is <code>nil</code> instead of an exception being raised.</p>

<p>If we log in as a user who has no roles now we can add a comment and update it but not the comments made by anyone else.</p>

<div class="imageWrapper">
  <img src="/system/photos/269/original/E192I06.png" width="815" height="543" alt="Guest users can edit only their own comments."/>
</div>

<p>Next we&rsquo;ll modify the code to add the abilities for moderators. Moderators should be able to modify any comment so we&rsquo;ll update the update comment ability to allow this.</p>
<pre class="ruby">
can :update, Comment do |comment|
  comment.try(:user) == user || user.role?(:moderator)
end
</pre>
<p>We have one more role left to cover, <code>:author</code>. Authors should be able to create articles and modify any articles that they have written. To add these abilities we just need to add the following code to the <code>Ability</code> class.</p>
<pre class="ruby">
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new

    if user.role? :admin
      can :manage, :all
    else
      can :read, :all
      can :create, Comment
      can :update, Comment do |comment|
        comment.try(:user) == user || user.role?(:moderator)
      end
      if user.role?(:author)
        can :create, Article
        can :update, Article do |article|
          article.try(:user) == user
        end
      end
    end
  end
end
</pre>
<p>As we did with guest users and comments we pass the current article to a block in the update article ability and check that the article&rsquo;s user is the current user.</p>

<p>Now we have all of our abilities defined for each user role. The nice thing about CanCan is that it allows us to define all of the abilities in one location and the rest of the application will reflect these changes.</p>

<h3>A Prettier Error Page</h3>

<p>If a user calls an action that they don&rsquo;t have access to they will see a rather ugly error page showing an <code>AccessDenied</code> exception. We can change this so that they see a better-looking custom error page instead.</p>

<p>Rails provides a method called <code>rescue_from</code> that we can place in our <code>ApplicationController</code>. We pass it an exception and pass it either a method or a block. We&rsquo;ll pass a block and inside it make the application show a flash error message and redirect to the home page.</p>
<pre class="ruby">
rescue_from CanCan::AccessDenied do |exception|
  flash[:error] = &quot;Access denied!&quot;
  redirect_to root_url
end
</pre>
<p>If a user without roles now tries to edit an article by typing the URL in directly they&rsquo;ll be redirected to the home page and told that they can&rsquo;t do that.</p>

<div class="imageWrapper">
  <img src="/system/photos/270/original/E192I07.png" width="818" height="359" alt="An flash message is shown if an attempt to access an unauthorized action is made."/>
</div>

<p>That&rsquo;s it for this episode. For more details or to report an issue visit Ryan&rsquo;s <a href="http://github.com/ryanb/cancan">GitHub page</a> for the project.</p>