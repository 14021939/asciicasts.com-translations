<p>In this episode we&rsquo;ll look at Active Model Serializers which be used to generate a JSON API in Rails. Below is a screenshot from a fairly standard blogging application with multiple articles, each of which can have many comments. We want to provide a JSON API to go alongside the HTML view so that if we append a <code>.json</code> to the URL we&rsquo;ll get the article&rsquo;s data.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1489/original/E409I01.png" width="800" height="500" alt="Our blogging application."/>
</div>

<p>If we try this now we&rsquo;ll see an exception as our application doesn&rsquo;t know how to respond to JSON requests. This is easy to fix: in our <code>ArticlesController</code> we can add a <code>respond_to</code> block to the show action so that we can see the JSON representation of an article.</p>

``` /app/controllers/articles_controller.rb
def show
  @article = Article.find(params[:id])
  respond_to do |format|
    format.html
    format.json { render json: @article }
  end
end
```

<p>When we load the page for an article now we&rsquo;ll see its data as JSON.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1490/original/E409I02.png" width="800" height="300" alt="We can now view an article in JSON by appending .json to its URL."/>
</div>


<h3>Customizing The Output</h3>

<p>This is a fairly common way to generate a JSON API in Rails but we often need to further customize the output. We can do this by either passing options in through the controller or by overriding the <code>as_json</code> method in the model but both of these approaches can get messy fairly quickly. This is where tools like the Active Model Serializer gem come in handy so we&rsquo;ll add it to our application. We use it in the usual way by adding to the gemfile and running <code>bundle</code> to install it.</p>

``` /Gemfile
gem 'active_model_serializers'
```

<p>This gem provides a generator which we need to run for each model that we want to present through the API. If we were using the resource generator in Rails it would make this automatically. We&rsquo;ll use this to make a serializer for our articles.</p>

``` terminal
$ rails g serializer article
```

<p>This generator creates a single file in a new <code>app/serializers</code> directory. This means that we now have a dedicated class that we can use to fully customize the JSON output and usefully this gem includes hooks so that when we try to render out a model in a JSON format it will automatically look for a serializer with the same name and if it finds it, use it to fetch the JSON data. In this class we can specify the attributes that we want to include in the output.</p>

``` /app/serializers/article_serializer.rb
class ArticleSerializer < ActiveModel::Serializer
  attributes :id, :name, :content
end
```

<p>If we reload the page now we&rsquo;ll see the JSON for the article rendered out through the serializer class.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1491/original/E409I03.png" width="800" height="300" alt="The JSON is now generated by the serializer."/>
</div>

<p>There&rsquo;s one key difference here: all the attributes are now included in a root node called <code>article</code> and this is different to how Rails generates JSON by default. We might not want this behaviour, depending on how we want our API to be consumed, and we can disable the root node by passing in the root option in our controller acton and setting it to <code>false</code>.</p>

``` /app/controllers/articles_controller.rb
format.json { render json: @article, root: false }
```

<p>If we want all our serialized objects to behave this way we can define a <code>default_serializer_options</code> method and set our default options there.</p>

``` /app/controllers/articles_controller.rb
def default_serializer_options
  {root: false}
end
```

<p>The Active Model Serializer will automatically pick this up and if we move this up into the <code>ApplicationController</code> it&rsquo;s included in all the controllers. We want to keep the route node, so we won&rsquo;t add this method to our app. Instead, we&rsquo;ll go back to our serializer class to see how we can further customize the output. Let&rsquo;s say that we want to add attributes that aren&rsquo;t methods defined on the model, such as the article&rsquo;s URL. We can define a method in the serializer and it will use this instead of delegating to the model. We have access to the URL helper methods here so we can use <code>article_url</code> to get the article&rsquo;s URL. We pass this object which represents the model that the serializer is focussed on.</p>

``` /app/serializers/article_serializer.rb
class ArticleSerializer < ActiveModel::Serializer
  attributes :id, :name, :content, :url

  def url
    article_url(object)
  end
end
```

<p>Being able to customize attributes through methods makes this serializer easy to use. Another useful feature is its support for associations. To include data from an article&rsquo;s comments we just use has_many and pass it the name of the association.</p>

``` /app/serializers/article_serializer.rb
class ArticleSerializer < ActiveModel::Serializer
  attributes :id, :name, :content, :url
  has_many :comments

  def url
    article_url(object)
  end
end
```

<p>When we reload the page now we&rsquo;ll see that the JSON includes the data for the associated comments.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1492/original/E409I04.png" width="800" height="300" alt="The JSON now includes the data for the associated comments."/>
</div>

<p>As you might expect we can customize the comments&rsquo; attributes by generating another serializer, so we&rsquo;ll do that now.</p>

``` terminal
$ rails g serializer comment
```

<p>We&rsquo;ll keep this one simple and just include the <code>id</code> and <code>content</code> attributes.</p>

``` /app/serializers/comment_serializer.rb
class CommentSerializer < ActiveModel::Serializer
  attributes :id, :content
end
```

<p>This behaviour, where if a serializer isn&rsquo;t found the controller falls back to the default Rails serialization is really useful as it means that we can add serializers only when we need custom behaviour.</p>

<p>So far our comments data has been nested within the root <code>article</code> node. If we want it to be up at the root level we can do so and some JavaScript client-side frameworks do perform better if the data is like this. We can do this by changing our <code>ArticleSerializer</code> and adding a call to embed, specifying <code>ids</code> so that any associations will have just their <coe>ids</coe> included in the articles&rsquo; JSON data. If we also pass <code>include: true</code> then the comments&rsquo; data is also included at the root level.</p>

``` /app/serializers/article_serializer.rb
embed :ids, include: true
```

<p>When we reload the page now the comments data is included at the top, outside the <code>article</code> root node. The article&rsquo;s data now has a <code>comment_ids</code> attribute which includes the <code>ids</code> of the associated comments. This way we can keep our comments data separate and only include it as needed, although this depends on how we want the API to be consumed.</p> 

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1493/original/E409I05.png" width="800" height="300" alt="The comments ids are now also included in the JSON"/>
</div>


<h3>Conditional Attributes</h3>

<p>If there are attributes that we want to include conditionally we can do so. Let&rsquo;s say that we want to include an <code>edit_url</code> but only if the current user is an admin. We can&rsquo;t really do this through <code>attributes</code> but we can override the <code>attributes</code> method and any hash returned will be converted and added to the JSON output.</p>

``` /app/serializers/article_serializer.rb
def attributes
  data = super
  data[:edit_url] = edit_article_url(object)
  data
end
```

<p>We want to keep the current behaviour so we first call <code>super</code> to get the data hash. We can then modify this and return it. We&rsquo;ve added an <code>edit_url</code> attribute and set it to the article&rsquo;s URL and while we haven&rsquo;t yet made this conditional we&rsquo;ll try it to see if it works.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1494/original/E409I06.png" width="800" height="300" alt="Finally we include the edit_url for the article."/>
</div>

<p>It does: the <code>edit_url</code> attribute is now displayed in the output. Next we&rsquo;ll make this attribute conditional and only display it if the current user is an admin. The serializer is outside the controller and view layers so we can&rsquo;t simply get the <code>current_user</code> here. To get around this problem there&rsquo;s an object that&rsquo;s passed in to every serializer called scope which defaults to the current user object.</p>

``` /app/serializers/article_serializer.rb
def attributes
  data = super
  data[:edit_url] = edit_article_url(object) if scope.admin?
  data
end
```

<p>If we try using this to make the <code>edit_url</code> attribute conditional, though, we get an exception when the page is reloaded saying that there&rsquo;s an undefined admin? method on the <code>scope</code> object. This means that the scope object isn&rsquo;t set to the current user and the issue is how we have the <code>current_user</code> method defined in our <code>ApplicationController</code>.</p> 

``` /app/controllers/application_controller.rb
private

def current_user
  OpenStruct.new(admin?: false)
end
helper_method :current_user
```

<p>For now this simply stubs out a <code>current_user</code> object using <code>OpenStruct</code> which is a handy way to quickly add fake authentication when we&rsquo;re developing an application. This method is marked as <code>private</code> which prevents the serializer from detecting it. If we make it <code>protected</code> instead this will now work and the <code>edit_url</code> is no longer displayed as our fake user isn&rsquo;t an admin.</p>

<p>Our serializer is now working well but we have some issues with how the scope works. One problem is that it loads the current user record every time it makes a JSON request in our application, even if the user record isn&rsquo;t accessed in the serializer. This can result in unnecessary database queries and potential performance issues. Another issue is that the name <code>scope</code> is rather generic and it&rsquo;s not really obvious that the <code>admin?</code> method is called on the current user when we call it on <code>scope</code>. It would be much better if we could call <code>current_user</code> directly in our serializer. To get this to work we can customize the scope object that&rsquo;s passed in to our serializers by changing the <code>ApplicationController</code>, calling <code>serialization_scope</code> and telling it to use something other than the current user, such as a <code>view_context</code>.</p>

``` /app/controllers/application_controller.rb
serialization_scope :view_context
```

<p>We can now call the current user through this view context and any other helper methods that we might need to access within our serializer. We&rsquo;ll go back to our serializer and tell it to delegate the <code>current_user</code> method to the scope and then call <code>admin?</code> on that.</p>

``` /app/serializers/article_serializer.rb
delegate :current_user, to: :scope

def attributes
  data = super
  data[:edit_url] = edit_article_url(object) if current_user.admin?
  data
end
```

<p>Our page now has the same functionality as it did before but the current user is only loaded in as needed. One downside of this approach is that it can make testing a little more difficult as we need to provide access to the entire view context for the serializer. To get around this we can test it in a similar way to how we test helper methods by inheriting from <code>ActionView::TestCase</code>. This will automatically set up the view context for us so that we can pass it into the serializer.</p>

<h3>Generating JSON Outside JSON Requests</h3>

<p>We&rsquo;ll finish this episode with one last tip. What do we do if we want to generate this JSON data outside a JSON request? For example lets say that we want to embed the JSON data for the articles on the <code>index</code> page. We could do this in a <code>data</code> attribute on one on the page&rsquo;s elements. This can be a little complicated to do so we&rsquo;ll create a helper method to create the attribute&rsquo;s content.</p>

``` /app/views/articles/index.html.erb
<div id="articles" data-articles="<%= json_for @articles %>">
```

<p>The helper method to generate the data will look like this:</p>

``` /app/helpers/application_helper.rb
module ApplicationHelper
  def json_for(target, options = {})
    options[:scope] ||= self
    options[:url_options] ||= url_options
    target.active_model_serializer.new(target, options).to_json
  end
end
```

<p>This method accepts a target object, which can be an ActiveRecord relation or a model. It first sets the <code>:scope</code> option for the serializer to <code>self</code>, which is the view context and a <code>:url_options</code> which it is important to pass in so that we don&rsquo;t get any errors out host option being undefined. Finally we call <code>active_model_serializer</code> on the object that&rsquo;s being passed in. This is a method that the gem adds to relations and models so that we can determine what serializer it should use. We then create an instance of this serializer, passing in the options, and convert it to JSON.</p> 

<p>If we reload the page now and view the source we&rsquo;ll see the articles&rsquo; data in the <code>data-articles</code> attribute.</p> 

``` html
data-articles="[{"id":1,"name":"Superman"...
```

<p>That wraps up our episode on ActiveModel Serializers. It&rsquo;s also worth taking a look at episodes <a href="http://railscasts.com/episodes/320-jbuilder">320</a> and <a href="http://railscasts.com/episodes/322-rabl">322</a> which cover JBuilder and RABL. These generate JSON in a different way by utilizing view templates instead of serializer objects. There are benefits to both approaches and while the object-orientated nature of Active Model Serializers may suit in some scenarios having the serialization done in the view layer may be a better approach at other times.</p>