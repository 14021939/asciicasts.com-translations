<p>En Rails 3.0 ActionMailer ha sufrido cambios importantes: ha sido dotado
de una nueva API y además utiliza la gema <a 
href="http://lindsaar.net/2010/1/23/mail-gem-version-2-released">Mail</a>
en lugar de la gema TMail como hasta ahora.  En este episodio veremos cómo
podeos enviar correos desde nuestras aplicaciones Rails.</p>

<p>Como demostración crearemos una nueva aplicación Rails 3 llamada <code>mailit</code>.</p>

<pre class="terminal">rails mailit
</pre>

<p>A continuación generaremos el andamiaje de un modelo <code>User</code> con
los atributos <code>name</code> y <code>email</code> y que hará las veces de
página de registro.</p>

<pre class="terminal">rails g scaffold user name:string email:string
</pre>
<p>Ejecutamos las migraciones de base de datos:</p>
<pre class="terminal">rake db:migrate
</pre>

<p>El código generado incluye una página para crear usuarios.  Queremos
crear un usuario nuevo y enviarles un email de confirmación cuando se
envíe el formulario.</p>

<div class="imageWrapper">
  <img src="/system/photos/348/original/E206I01.png" width="796" height="315" alt="El formulario de registro de usuario."/>
</div>

<p>Lo primero que haremos será crear un nuevo inicializador al que
llamaremos <code>setup_mail.rb</code> y donde pondremos las opciones
de configuración.  Por defecto ActionMailer utiliza sendmail (si este
está configurado en nuestra máquina) pero también podemos especificar
una configuración SMTP durante la inicialización.</p>

<p class="codeFilePath">/config/initializers/setup_mail.rb</p>
<pre class="ruby">
  ActionMailer::Base.smtp_settings = {
  :address              =&gt; &quot;smtp.gmail.com&quot;,
  :port                 =&gt; 587,
  :domain               =&gt; &quot;asciicasts.com&quot;,
  :user_name            =&gt; &quot;asciicasts&quot;,
  :password             =&gt; &quot;secret&quot;,
  :authentication       =&gt; &quot;plain&quot;,
  :enable_starttls_auto =&gt; true
  }
</pre>

<p>Es probable que queramos emplear un enfoque diferente cuando la
aplicación se encuentre en producción pero con esto nos bastará mientras
estemos en la fase de desarrollo.  Por supuesto, tendremos que cambiar las
opciones <code>domain</code>, <code>user_name</code>
y <code>password</code> para que coincidan con las de nuestra cuenta
de Gmail.</p>

<p>Una vez que hemos completado la configuración podemos generar
un nuevo <em>mailer</em> con el siguiente código:</p>

<pre class="terminal">
  rails g mailer user_mailer
</pre>

<p>Esto creará un nuevo archivo llamado <code>user_mailer.rb</code> en
el directorio <code>app/mailers/</code> de nuestra aplicación.  Las
versinoes anteriores de Rails dejaban las clases <em>mailer</em> en el
mismo directorio <code>/app/models</code>.  En Rails 3, estas clases
cuya función es específicamente el envío de correos han sido
promocionadas para tener su propio directorio.  Los <em>mailers</em>
en Rails 3 se comportan de manera parecida a los controladores
normales y por tanto comparten gran parte del código.</p>

<p>El código por defecto en la clase <code>UserMailer</code> tiene
el siguiente aspecto:</p>

<p class="codeFilePath">/app/mailers/user_mailer.rb</p>
<pre class="ruby">
  class UserMailer &lt; ActionMailer::Base
  default :from =&gt; &quot;from@example.com&quot;
  end
</pre>

<p>Vamos a borrar la línea <code>default</code> de esta clase por ahora
pero explicareoms lo que hace.</p>

<p>Tal y como haríamos en una aplicación Rails 2 tendremos que 
añadir un método a esta clase por cada tipo de correo que queramos
enviar.  En este caso sólo quremos un método que llamaremos
<code>registration_confirmation</code>.</p>

<p class="codeFilePath">/app/mailers/user_mailer.rb</p>
<pre class="ruby">
  class UserMailer &lt; ActionMailer::Base
  def registration_confirmation(user)
  mail(:to =&gt; user.email, :subject =&gt; &quot;Registered&quot;, :from =&gt; &quot;eifion@asciicasts.com&quot;)
  end
  end
</pre>

<p>Pasaremos a nuestro método <code>registration_confirmation</code>
un objeto <code>User</code> y todo lo que tiene que hacer nuestro
método es invocar el método <code>mail</code> pasándole
un <em>hash</em> con argumentos tales
como <code>to:</code>, <code>:from</code>,
y <code>:subject</code>.</p>

<p>Si en nuestra clase vamos a tener múltiples métodos que compartirán
opciones podemos mover estas opciones al método <code>default</code>
que eliminamos antes.  Si, por ejemplo, los emails siempre se van a 
enviar desde la misma dirección podemos poner la
opción <code>:from</code> en <code>default</code>, con lo que la clase
quedaría más o menos así:</p>


<p class="codeFilePath">/app/mailers/user_mailer.rb</p>
<pre class="ruby">
  class UserMailer &lt; ActionMailer::Base
  default :from =&gt; &quot;eifion@asciicasts.com&quot;

  def registration_confirmation(user)
  mail(:to =&gt; user.email, :subject =&gt; &quot;Registered&quot;)
  end
  end
</pre>


<p>En <code>default</code> podemos poner cualquier de las opciones
que acepta el método <code>mail</code>.</p>

<p>Los <em>mailers</em> de correo al igual que los controladores tienen que
tener asociado un archivo de vista.  La vista para nuestro correo de
registro estará en el directorio <code>/app/views/user_mailer</code>.
Dado que vamos a enviar correos en texto plano el archivo se llamará
<code>registration_confirmation.text.erb</code>.  En el cuerpo del correo 
aparecerá lo que pongamos en este archivo.</p>


<p class="codeFilePath">/app/views/user_mailer/registration_confirmation.text.erb</p>
<pre class="erb">
  Thank you for registering! 
</pre>  

<p>A continuación tenemos que escribir el código que enviará el correo
cuando se cree el usuario.  Hay a quien le gusta hacerlo utilizando
un <a href="http://api.rubyonrails.org/classes/ActiveRecord/Observer.html">Model
Observer</a> pero nosotros lo haremos en la capa del controlador.  La
razón para hacerlo así es que si utilizamos un <em>observer</em> y
durante nuestras pruebas creamos objetos <code>User</code> en
la consola de Rails, entonces se enviarán correos automáticamente lo que no
queremos que pase.  Sólo queremos que se envíen los correos cuando
estamos interactuando directamente con la propia aplicación, en cuyo
caso tendremos que estar pasando por el controlador.</p>

<p>Así que escribiremos el código para enviar el correo en la acción <code>create</code>
de <code>UsersController</code>.  Tan sólo tenemos que llamar al método
<code>registration_confirmation</code> que hemos escrito hace un momento pasándole
el usuario recién creado e invocar en cadena el método <code>deliver</code>.</p>

<p class="codeFilePath">/app/controllers/users_controller.rb</p>
<pre class="ruby">
  def create
  @user = User.new(params[:user])

  respond_to do |format|
  if @user.save
  UserMailer.registration_confirmation(@user).deliver
  format.html { redirect_to(@user, :notice =&gt; &#x27;User was successfully created.&#x27;) }
  format.xml  { render :xml =&gt; @user, :status =&gt; :created, :location =&gt; @user }
  else
  format.html { render :action =&gt; &quot;new&quot; }
  format.xml  { render :xml =&gt; @user.errors, :status =&gt; :unprocessable_entity }
  end
  end
  end
</pre>

<p>En Rails 2 esto se habría hecho de manera distinta porque habríamos
llamado a un método llamado <code>deliver_registration_confirmation</code>. 
Ahora tenemos un método que devuelve un objeto que representa el mensaje
de correo y sobre este objeto se invoca el método <code>deliver</code>, cosa
que podemos dejar para más adelante si nos interesa.</p>

<p>Podemos probar todo esto registrando un nuevo usuario.  Cuando enviemos
el formulario se debería enviar un correo electrónico.</p>

<div class="imageWrapper">
  <img src="/system/photos/349/original/E206I02.png" width="798" height="340" alt="El correo de registrado enviado por la aplicación"/>
</div>

<p>Funciona. Nuestro correo de registro ha sido enviado.</p>

<p>Pero, ¿y si queremos personalizar el correo de forma que aparezca
el nombre de usuario recién registrado?  Para eso tendremos que
propagar el objeto del usuario hacia la vista.  En Rails 3 esto es muy
sencillo porque como los <em>mailers</em> se comportan igual que los
controladores cualquier variable de instancia que creemos estará
disponible en la vista.  Lo único que tenemos que hacer es crear una
variable de instancia con el usuario que hemos recibido en el método
<code>registration_confirmation</code> para poder utilizarlo en la
vista.</p>

<p class="codeFilePath">/app/mailers/user_mailer.rb</p>
<pre class="ruby">
  def registration_confirmation(user)
  @user = user
  mail(:to =&gt; user.email, :subject =&gt; &quot;Registered&quot;)
  end
</pre>

<p>La llamada al método <code>mail</code> tiene que estar al final del método porque
devolverá el mensaje de correo y por tanto la variable de instancia tiene que haber
sido definida de antemano.</p>

<p>Ahora que tenemos la variable de instancia definida en el <em>mailer</em> podemos
utilizarla en la vista para mostrar el nombrel del usuario en el correo.</p>


<p class="codeFilePath">/app/views/user_mailer/registration_confirmation.text.erb</p>
<pre class="erb">&lt;%= @user.name %&gt;,

Thank you for registering!
</pre>

<p>Si volvemos a registrarnos otra vez en el cuerpo del correo aparecerá
el nombre del usuario.</p>

<div class="imageWrapper">
  <img src="/system/photos/350/original/E206I03.png" width="797"
       height="340" alt="El nombre del nuevo usuario aparece en el correo."/>
</div>

<p>También podemos mostrar un enlace en el correo  para que el usuario pueda
editar su perfil.  En las vistas podemos utilizar rutas por nombre, así que
podemos escribir algo como:</p>

<pre class="erb">Edit Profile: &lt;%= edit_user_url(@user) %&gt;
</pre>

<p>Sin embargo de entrada esto no funcionará porque nos falta dar un poco más de
información: la opción <code>:host</code> que contendrá el dominio
sobre el que opera nuestra aplicación.</p>


<p class="codeFilePath">/app/views/user_mailer/registration_confirmation.text.erb</p>
<pre class="erb">&lt;%= @user.name %&gt;,

Thank you for registering!

Edit Profile: &lt;%= edit_user_url(@user, :host =&gt; "localhost:3000") %&gt;
</pre>

<p>El motivo por el que hace falta esta opción extra es que los <em>mailers</em>
están totalmente desacoplados de la petición actual.  Se trata de una
decisión de diseño para que se puedan enviar correos sin responder a peticiones
a un controlador.</p>

<p>Para no tener que hacer esto en cada enlace de todas y cada una de las
vistas de correos que tengamos podemos definir el nombre del dominio en el
fichero de inicialización que creamos anteriormente.</p>


<p class="codeFilePath">/config/initializers/setup_mail.rb</p>
<pre class="ruby">
  ActionMailer::Base.smtp_settings = {
  :address              =&gt; &quot;smtp.gmail.com&quot;,
  :port                 =&gt; 587,
  :domain               =&gt; &quot;asciicasts.com&quot;,
  :user_name            =&gt; &quot;asciicasts&quot;,
  :password             =&gt; &quot;secret&quot;,
  :authentication       =&gt; &quot;plain&quot;,
  :enable_starttls_auto =&gt; true
  }

  ActionMailer::Base.default_url_options[:host] = &quot;localhost:3000&quot;
</pre>

<p>Por ahora sólo vamos a especificar el dominio, aunque en el <em>hash</em>
podríamos especificar culquier opción que quisiéramos.  Cuando nos registremos
otra vez veremos el enlace en el correo con la URL correcta.</p>

<div class="imageWrapper">
  <img src="/system/photos/351/original/E206I04.png" width="797" height="340" alt="The registration email now has a link to the user's profile."/>
</div>


<h3>Correos multiparte y con adjuntos</h3>

<p>También es bastante más fácil enviar correos multiparte en 
Rails 3. Lo único que hay que hacer es generar un nuevo archivo para
la parte HTML del email con el mismo nombre que la vista de texto, en
nuestro caso sería <code>registration_confirmation.html.erb</code>.  
En él pondremos una versión HTML sencilla de la vista del correo en 
texto plano:</p>

<p class="codeFilePath">/app/views/user_mailer/registration_confirmation.html.erb</p>
<pre class="erb">&lt;p&gt;&lt;%= @user.name %&gt;,&lt;/p&gt;

&lt;p&gt;Thank you for registering!&lt;/p&gt;

&lt;p&gt;&lt;%= link_to "Edit Profile", edit_user_url(@user, :host =&gt; "localhost:3000") %&gt;&lt;/p&gt;
</pre>

<p>Si ahora vemos este correo en un cliente capaz de mostrar correos
en HTML veremos un enlace.  Se envían ambas partes de forma que las
aplicaciones que no sean capaces de mostrar HTML visualizará la versión
en texto plano.</p>

<div class="imageWrapper">
  <img src="/system/photos/352/original/E206I05.png" width="797" height="340" alt="Vista en HTML del correo."/>
</div>


<p>También es inmediato añadir un adjunto, tan sólo hay que añadir
una nueva llamada a <code>attachments</code>, poniendo como clave el nombre
del adjunto y pasando el archivo correspondiente.</p>

<p class="codeFilePath">/app/mailers/user_mailer.rb</p>
<pre class="ruby">
  def registration_confirmation(user)
  @user = user
  attachments[&quot;rails.png&quot;] = File.read(&quot;#{Rails.root}/public/images/rails.png&quot;)
  mail(:to =&gt; &quot;#{user.name} &lt;#{user.email}&gt;&quot;, :subject =&gt; &quot;Registered&quot;)
  end
</pre>

<p>Si nos volvemos a registrar un vez más veremos que le correo ahora
tiene el fichero <code>rails.png</code> como adjunto.  Obsérvese también
que hemos cambiado la opción <code>:to</code< en el método <code>mail</code>
para incluir el nombre del usuario.</p>

<div class="imageWrapper">
  <img src="/system/photos/353/original/E206I06.png" width="765" height="340" alt="Inclusión de un adjunto."/>
</div>


<p>Como vemos, con la nueva API de ActionMailer es muy sencillo crear 
correos relativamente complicados.  Las opciones por defecto son
bastante sensatas, lo que es de ayuda, pero si podemos cambiarlas si 
necesitamos tener más control sobre cosas como los tipos de codificación,
etc.</p>

<h3>Interceptadores</h3>

<p>Para terminar este episodio, veremos una técnica para interceptar
los mensajes de correo antes de que sean enviados.  Esto nos viene bien,
por ejemplo, para cambiar la forma en que se tratan los mensajes en
modo de desarrollo de  forma que no se envíen a ningún usuario, sino
a una dirección de correo de nuestra elección.</p>

<p>Esta funcionalidad ha sido añadida recientemente a la gema Mail,
por lo que tendremos que actualizarnos a la última versión (2.1.3 o superior).
Podemos modificar el <code>Gemfile</code> de nuestra aplicación para
poner una referencia a la gema con la siguiente línea:</p>

<p class="codeFilePath">/Gemfile</p>
<pre class="ruby">
  gem &quot;mail&quot;, &quot;2.1.3&quot;
</pre>

<p>Luego, ejecutaremos <code>bundle install</code> para instalar 
la versión actualizada.</p>

<p>Lo siguiente que tenemos que hacer es crear la clase interceptadora.
Esta clase podría ir en el directorio <code>/lib</code>, y le pondremos
el nombre <code>development_mail_interceptor.rb</code>.</p>

<p class="codeFilePath">/lib/development_mail_interceptor.rb</p>
<pre class="ruby">
  class DevelopmentMailInterceptor
  def self.delivering_email(message)
  message.subject = &quot;[#{message.to}] #{message.subject}&quot;
  message.to = &quot;eifion@asciicasts.com&quot;
  end
  end
</pre>

<p>El método de clase <code>delivering_email</code> recibe el mensaje
de correo que esta a punto de ser enviado y cambia la línea de asunto
para incluir en él el nombre de la persona a la que iba dirigido el correo.
Luego se cambia el campo <code>to</code> para que el email se envíe a 
<code>eifion@asciicasts.com</code>.</p>

<p>A continuación tenemos que registrar el interceptador en nuestro
fichero de inicialización, lo que puede hacerse añadiendo la 
siguiente línea.</p>

<p class="codeFilePath">/config/initializers/setup_mail.rb</p>
<pre class="ruby">
  Mail.register_interceptor(DevelopmentMailInterceptor) if Rails.env.development?
</pre>

<p>Esto invocará al método <code>delivering_email</code> en nuestro
interceptador si nuestra aplicación está en modo de desarrollo. Cuando
se lance la siguiente beta de Rails 3.0 con una versión actualizada
de la gema Mail podremos reemplazar la llamada a <code>Mail.register_interceptor</code>
por <code>ActionMailer::Base.register_interceptor</code>.</p>

<p>Si creamos un nuevo usuario el envío del correo será dirigido a <code>eifion@asciicasts.com</code>
independientemente del destinatario al que iba dirigido originalmente, que
ahora aparecerá en la línea de asunto.</p>

<div class="imageWrapper">
  <img src="/system/photos/354/original/E206I07.png" width="765" height="340" alt="En modo de desarrollo el email se nos envía a nosotros en vez de a su destinatario."/>
</div>


<p>Esta es una forma de comprobar que nuestros emails funcionan cuando
estamos desarrollando la aplicación.</p>

<p>Y eso es todo por este episodio, esperamos que lo hayan encontrado
útil.  La nueva API de ActionMailer hace que sea mucho más sencillo
enviar correos desde aplicaciones Rails.</p>
