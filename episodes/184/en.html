<p>If you find writing the view code for forms rather long-winded, you&rsquo;ll be pleased to know that there&rsquo;s a gem called <a href="http://github.com/justinfrench/formtastic">Formtastic</a> which provides a more concise way to do it. With it, fairly complex forms can be created with relatively little code as we&rsquo;ll show you in this episode.</p>

  <h3>Creating The Vet App</h3>

  <p>Before we get started with Formtastic it&rsquo;s worth mentioning a <a href="http://github.com/grimen/formtastic_tmbundle">TextMate bundle</a> that&rsquo;s available. This provides a number of useful snippets that can make creating forms even easier. </p>

  <p>To demonstrate Formtastic we&rsquo;re going to create a new Rails app. This application will keep track of animal patients in a vet&rsquo;s surgery, so we&rsquo;ll call it <code>vet</code> and create it in the normal way.</p>
  <pre class="terminal">rails vet</pre>
  <p>Formtastic is supplied as a gem. We can include it in our application by adding the following line to our application&rsquo;s <code>/config/environment.rb</code> file. (If you&rsquo;re using TextMate and you&rsquo;ve installed the Formtastic bundle you can use <code>ftgem</code> and <code>&lt;TAB&gt;</code> as a shortcut).</p>

  <pre class="ruby">config.gem &#x27;justinfrench-formtastic&#x27;, :lib =&gt; &#x27;formtastic&#x27;, :source =&gt; &#x27;http://gems.github.com&#x27;</pre>
  <p>To make sure the gem is installed we just need to run</p> 
  <pre class="terminal">
  sudo rake gems:install
  </pre>
  <p>and then we&rsquo;re ready to begin writing our application.</p>

  <p>Our application will make use of some of Ryan Bates&rsquo; <a href="http://github.com/ryanb/nifty-generators">nifty generators</a> to make it easier to write parts of the application. The one we&rsquo;ll use first is the <code>nifty_layout</code> generator which we&rsquo;ll use to create a layout file and stylesheet.</p>
  <pre class="terminal">
  script/generate nifty_layout
  </pre>
  <p>Next we&rsquo;ll generate our first model, making use of the <code>nifty_scaffold</code> generator to create a controller and views to go with it. We&rsquo;re going to put our animals into categories so we&rsquo;ll call our model <code>Category</code> and give it <code>name</code> and <code>description</code> attributes.</p>
  <pre class="terminal">
  script/generate nifty_scaffold category name:string description:text
  </pre>
  <p>We can now migrate our database.</p>
  <pre class="terminal">rake db:migrate</pre>
  <p>If we start up our new application and navigate to the new category page we&rsquo;ll see the scaffold-generated view code.</p>
  <div class="imageWrapper">
    <img src="/system/photos/214/original/E184I01.png" width="800" height="439" alt="The default New Category page."/>
  </div>

  <p>The code generated by the scaffolding for the form above is this:</p>
  <pre class="ruby">
  &lt;% form_for @category do |f| %&gt;
    &lt;%= f.error_messages %&gt;
    &lt;p&gt;
      &lt;%= f.label :name %&gt;&lt;br /&gt;
      &lt;%= f.text_field :name %&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;%= f.label :description %&gt;&lt;br /&gt;
      &lt;%= f.text_area :description, :rows =&gt; 5 %&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
  &lt;% end %&gt;
  </pre>
  <p>This is normal Rails form code, starting with a <code>form_for</code> and with each field in the form defined separately along with its label. Finally there&rsquo;s a submit button so that we can add a new category.</p>

  <p>Formtastic doesn&rsquo;t override any of these standard form methods so we can still use them in a Formtastic form. If we replaced the <code>form_for</code> in the form above with Formtastic&rsquo;s <code>semantic_form_for</code> the form would work just the same. There&rsquo;s not much point in doing that, however; the real advantage comes when we use Formtastic&rsquo;s form methods. With them we can change our form to look like this:</p>
  <pre class="ruby">
  &lt;% semantic_form_for @category do |f| %&gt;
   &lt;%= f.inputs %&gt;
   &lt;%= f.buttons %&gt;
  &lt;% end %&gt;
  </pre>
  <p>The <code>inputs</code> method is a convenient way to generate all the input fields for a model and, likewise, the <code>buttons</code> method generates a submit button. If we reload the form now it&rsquo;ll look a little different.</p>
  <div class="imageWrapper">
    <img src="/system/photos/215/original/E184I02.png" width="801" height="502" alt="The New Category page using Formtastic code."/>
  </div>

  <p>This form is now rendered using Formtastic&rsquo;s form methods. The most noticeable difference is that whereas the scaffold-generated form used paragraph tags to separate the fields Formtastic uses ordered lists and fieldsets to separate the input fields from the button.</p>

  <p>The form doesn&rsquo;t look particularly pretty as it stands, but we can fix this by applying some CSS. Formtastic comes with some existing stylesheets that we can generate to save us having to do all of the work ourselves. If we run</p>
  <pre class="terminal">
  script/generate formtastic_stylesheets
  </pre>
  <p>two new stylesheets will be created in our application&rsquo;s <code>/public/stylesheets</code> directory and we can then reference these new stylesheets from our layout file. In the head section of our layout we&rsquo;re referencing one stylesheet already.</p>
  <pre class="ruby">
  &lt;head&gt;
    &lt;title&gt;&lt;%= h(yield(:title) || &quot;Untitled&quot;) %&gt;&lt;/title&gt;
    &lt;%= stylesheet_link_tag &#x27;application&#x27; %&gt;
    &lt;%= yield(:head) %&gt;
  &lt;/head&gt;
  </pre>
  <p>We can add the two Formtastic stylesheets here to include them on every page in our application.</p>
  <pre class="ruby">
  &lt;%= stylesheet_link_tag &#x27;application&#x27;, &#x27;formtastic&#x27;, &#x27;formtastic-changes&#x27; %&gt;
  </pre>
  <p>The second file, <code>formtastic-changes</code>, is where we should make any changes to the default styles provided in the other stylesheet. As we now have multiple stylesheets we should make use of Rails&rsquo; caching option so that the files are combined into one when the application is run in production mode. (This applies to multiple JavaScript files as well.)</p>
  <pre class="ruby">
  &lt;%= stylesheet_link_tag &#x27;application&#x27;, &#x27;formtastic&#x27;, &#x27;formtastic-changes&#x27;, :cache =&gt; &#x27;base&#x27; %&gt;
  </pre>
  <p>Using caching like this will mean that fewer files need to be requested from the server when the page loads as the three stylesheet files will be combined into one called <code>base.css</code>.</p>

  <p>If we reload the form now it&rsquo;ll look a little better, but it&rsquo;s still not quite how it&rsquo;s supposed to look.</p>

  <div class="imageWrapper">
    <img src="/system/photos/216/original/E184I03.png" width="800" height="475" alt="The form's layout isn't quite correct."/>
  </div>

  <p>This is due to a couple of lines in Formtastic&rsquo;s stylesheet.</p>
  <pre class="terminal">
  html[xmlns] form.formtastic fieldset { display: block; }

  html[xmlns] form.formtastic fieldset ol li { display: block; }
  </pre>

  <p>The two CSS selectors above expect the pages&rsquo; opening <code>&lt;html&gt;</code> tag to have an <code>xmlns</code> attribute. In the layout file generated by the nifty_layout generator the tag doesn&rsquo;t have this so we&rsquo;ll have to add it to get the form to display as it should.</p>
  <pre class="terminal">
  &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
  </pre>
  <p>Reload the form now and we&rsquo;ll see the text fields line up as we&rsquo;d expect them to. Now that we have the form looking as it should we can add a couple of categories, one for dogs and one for cats. We&rsquo;ll use these shortly when we create the form for the animals themselves.</p>

  <div class="imageWrapper">
    <img src="/system/photos/217/original/E184I04.png" width="800" height="475" alt="Adding our first category."/>
  </div>

  <h3>A More Complex Example</h3>

  <p>We&rsquo;ll move on now to the form for the animals. As we did with the categories we&rsquo;ll start by generating a scaffold.</p>
  <pre class="terminal">
  script/generate nifty_scaffold animal name:string category_id:integer born_on:date female:boolean
  </pre>
  <p>The <code>Animal</code> model will have <code>name</code>, <code>born_on</code> and <code>female</code> attributes along with a <code>category_id</code> so that we can put each animal into a <code>Category</code>. After creating the scaffold we&rsquo;ll migrate our database again so that the new table is created in the database.</p>
  <pre class="terminal">
  rake db:migrate
  </pre>
  <p>The next step is to set up the relationship between the models so that an animal belongs to a category&hellip;</p>
  <pre class="terminal">
  class Animal &lt; ActiveRecord::Base
    attr_accessible :name, :category_id, :born_on, :female
    belongs_to :category
  end
  </pre>
  <p>&hellip;and a category has many animals.</p>
  <pre class="ruby">
  class Category &lt; ActiveRecord::Base
    attr_accessible :name, :description
    has_many :animals
  end
  </pre>
  <p>The form generated by the scaffolding is shown below. We want to replace this with some Formtastic code so we&rsquo;ll be changing this soon.</p>

  <div class="imageWrapper">
    <img src="/system/photos/218/original/E184I05.png" width="800" height="488" alt="The default New Animal page."/>
  </div>

  <p>As we did with the category form we&rsquo;ll be replacing the default <code>form_for</code> code with a Formtastic <code>semantic_form_for</code> form.</p>
  <pre class="ruby">
  &lt;% semantic_form_for @animal do |f| %&gt;
    &lt;% f.inputs do %&gt;
      &lt;%= f.input :name %&gt;
      &lt;%= f.input :born_on %&gt;
      &lt;%= f.input :category %&gt;
      &lt;%= f.input :female %&gt;
    &lt;% end %&gt;
    &lt;%= f.buttons %&gt;
  &lt;% end %&gt;
  </pre>
  <p>We want a little more control over our form fields this time as we&rsquo;re going to customise them shortly so we&rsquo;ve passed <code>f.inputs</code> a block, inside of which we&rsquo;ve used the <code>input</code> method to define each field. After we&rsquo;ve closed the block we can add our submit button with <code>f.buttons</code> as we did before.</p>

  <p>If we reload the form now we&rsquo;ll see the fields as rendered by Formtastic.</p>

  <div class="imageWrapper">
    <img src="/system/photos/219/original/E184I06.png" width="801" height="477" alt="The New Animal page with the Formtastic controls on it."/>
  </div>

  <p>Formtastic has created appropriate form fields according the the <code>Animal</code> model&rsquo;s attributes&rsquo; types. Although you can&rsquo;t see it here it has even worked out that the <code>category_id</code> field is a association and populated the category dropdown with the two categories we added earlier.</p>

  <p>There are a few changes we want to make to this form. By default, the year part of the date field is only populated five years either side of the current year and we need to show dates further back than that. Also, we want to remove the blank option from the <code>category</code> dropdown and show the <code>female</code> field as a pair of radio buttons rather than as a checkbox.</p>

  <p>We can customise fields by using the same options that we pass to Rails&rsquo; form helper methods. This means that we can pass <code>born_on</code> a <code>:start_year</code> and use an <code>:include_blank =&gt; false</code> parameter in our category to remove the blank option.</p>
  <pre class="ruby">
  &lt;% semantic_form_for @animal do |f| %&gt;
    &lt;% f.inputs do %&gt;
      &lt;%= f.input :name %&gt;
      &lt;%= f.input :born_on, :start_year =&gt; 1900 %&gt;
      &lt;%= f.input :category, :include_blank =&gt; false %&gt;
      &lt;%= f.input :female, :as =&gt; :radio %&gt;
    &lt;% end %&gt;
    &lt;%= f.buttons %&gt;
  &lt;% end %&gt;
  </pre>
  <p>We have to treat the <code>female</code> field a little differently as we&rsquo;re changing the type of form element. To specify a different type of field from the default Formtastic has an <code>:as</code> parameter. We can use <code>:as =&gt; :radio</code> to change the type to radio buttons.</p>

  <p>If we take another look at the form now we&rsquo;ll see the changes we made reflected there, with the dates starting from 1900, the blank option removed from the category and the female checkbox replaced by two radio buttons.</p>

  <div class="imageWrapper">
    <img src="/system/photos/220/original/E184I07.png" width="801" height="477" alt="The gender field is now rendered as radio buttons."/>
  </div>

  <p>The radio buttons are an improvement on the checkbox, but instead of &ldquo;yes&rdquo; and &ldquo;no&rdquo; we&rsquo;d like the field to be labelled &ldquo;Gender&rdquo; and the radio buttons labelled &ldquo;Male&rdquo; and &ldquo;Female&rdquo;. Does Formtastic allow this level allow this level of customisation? It does. We can make use of the <code>:label</code> and <code>:collection</code> options to set the values of the label and the radio buttons.</p>
  <pre class="ruby">
  &lt;%= f.input :female, :as =&gt; :radio, :label =&gt; &quot;Gender&quot;, :collection =&gt; [[&quot;Male&quot;, false], [&quot;Female&quot;, false]] %&gt;
  </pre>
  <p>As the name implies the <code>:label</code> option sets the name of the label, while the <code>:collection</code> option takes a array of arrays specifying the name and value of each radio button.</p>

  <p>The form now looks just how we want it to.</p>

  <div class="imageWrapper">
    <img src="/system/photos/221/original/E184I08.png" width="801" height="477" alt="The labels on the radio buttons are changed to the text we want."/>
  </div>

  <p>Our form is now complete and we can use it to create as many new animals as we want.</p>

  <h3>Taking it Further</h3>

  <p>With Formtastic we have successfully created a fairly complex form with relatively little view code, using its customisation options to alter some of the fields to suit our needs. There&rsquo;s still quite a bit of Formtastic that we haven&rsquo;t covered though so we&rsquo;ll be going into it in more depth in the next episode.</p>