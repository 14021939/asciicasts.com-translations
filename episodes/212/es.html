<head><base href="http://asciicasts.com"></head>
<p>Esta semana tenemos un episodio un poco diferente.  Se trata de un ejercicio de refactorización que mostrará una divertida técnica de Ruby que hemos bautizado como el Delegador Dinámico.</p>

<p>Como demostración de esta técnica utilizaremos una aplicación que es una tienda sencilla, con un modelo 
<code>Product</code> que tiene su controlador asociado, <code>ProductsController</code>. La acción <code>index</code> de este controlador permite filtra la lista de productos por nombre y precio.  Si pasamos en la URL uno o varios parámetros llamados <code>name</code>, <code>price_lt</code> y <code>price_gt</code> se pueden hacer búsquedas de productos que coincidan con ese nombre y precios, por ejemplo, todos los productos cuyo nombre contiene &ldquo;video&rdquo; y cuestan más de &pound;50.</p>

<div class="imageWrapper">
  <img src="/system/photos/377/original/E212I01.png" width="800" height="315" alt="Filtro de la lista de productos."/>
</div>

<p>Antes de refactorizar la acción <code>index</code>, echémosle un vistazo para ver qué es lo que hace.</p>

<p class="codeFilePath">/app/controllers/products_controller.rb</p>
<pre class="ruby">
class ProductsController &lt; ApplicationController
  def index
    @products = Product.scoped
    @products = @products.where(&quot;name like ?&quot;, &quot;%&quot; + params[:name] + &quot;%&quot;) if params[:name]
    @products = @products.where(&quot;price &gt;= ?&quot;, params[:price_gt]) if params[:price_gt]
    @products = @products.where(&quot;price &lt;= ?&quot;, params[:price_lt]) if params[:price_lt]
  end

  # Other actions
end
</pre>

<p>Se trata de una aplicación Rails 3, así que estamos usando el método <code>where</code> para agregar condiciones a la consulta si recibimos los parámetros correspondientes pero antes de hacerlo utilizamos <code>Product.scoped</code> para recuperar todos los productos.  Puede que no estemos familiarizados con este método, pero en esencia no es más que otra forma de decir <code>Product.all</code>, la diferencia estriba en que el método <code>all</code> realizará una consulta a la base de datos tan pronto como sea ejecutado y devolverá un <em>array</em> de productos. No queremos que esto ocurra hasta que no hayamos aplicado nuestros filtros por lo que usando <code>scoped</code> podremos añadir condiciones a la consulta antes de ejecutarla.</p>

<p>Veamos cómo refactorizar esta acción.  El primer paso que vamos a dar será sacar la lógica del controlador, ya que no pertenece ahí.  En cualquier lenguaje orientado a objetos, si descubrimos que desde un objeto llamamos a muchos métodos de otro por lo general esto quiere decir que deberíamos mover esa lógica al otro objeto.  En este caso en la acción <code>index</code> de la clase <code>ProductController</code>  estamos invocando cuatro métodos del modelo <code>Product</code> lo que sugiere que este código debería estar en el modelo.</p>


<p>Quitaremos el código de la acción <code>index</code> y en su lugar pondremos una llamada a un nuevo método de clase en el modelo <code>Product</code>, llamada <code>search</code>, pasándole el <em>hash</em> de parámetros para que sepa qué es lo que tiene que buscar.</p>

<p class="codeFilePath">/app/controllers/products_controller.rb</p>
<pre class="ruby">
class ProductsController &lt; ApplicationController
  def index
    @products = Product.search(params)
  end

  # Other actions
end
</pre>

<p>A continuación escribiremos este método en el modelo <code>Product</code>.  Queremos que este método sea de clase, asi que lo definiremos como <code>self.search</code>.  Este código será el mismo que teníamos en el controlador pero en lugar de la variable de instancia que teníamos en el controlador aquí tendremos una variable local que devolveremos al salir del método.</p>

<p class="codeFilePath">/app/models/product.rb</p>
<pre class="ruby">
class Product &lt; ActiveRecord::Base
  belongs_to :category
  
  def self.search(params)
    products = scoped
    products = products.where(&quot;name like ?&quot;, &quot;%&quot; + params[:name] + &quot;%&quot;) if params[:name]
    products = products.where(&quot;price &gt;= ?&quot;, params[:price_gt]) if params[:price_gt]
    products = products.where(&quot;price &lt;= ?&quot;, params[:price_lt]) if params[:price_lt]    
    products
  end 

end
</pre>

<p>Si recargamos la página veremos que parece que no hemos roto nada.</p>

<div class="imageWrapper">
  <img src="/system/photos/377/original/E212I01.png" width="800" height="315" alt="La página sigue funcionando."/>
</div>

<p>Está claro que al recargar la página sólo hemos comprobado que los cambios del código funcionan para estos parámetros específícos.   Es en este tipo de escenarios en los que es mejor aplicar el Desarrollo Basado en Tests: cada vez se nos hará más tedioso ir recargando la página y no nos será fácil ir comprobando todos y cada uno de los caminos que puede seguir el código según los parámetros recibidos.  Es buena idea, sobre todo cuando estamos rfactorizando nuestro código, tener una batería de tests lo más completa posible para poder estar seguros de que no hemos introducido ningún efecto lateral.</p>

<p>Además al haber llevado el código al modelo tenemos la ventaja adicional de que éste será más fácil de probar porque sólo nos va a hacer falta escribir un test unitario contra el código del modelo en lugar de hacer un escenario completo de integración.</p>

<h3>Introducción al Delegador Dinámico</h3>

<p>Ya hemos refactorizado un poco el código moviendo la lógica de búsqueda al modelo, y vamos a ir un poco más lejos eliminando la necesidad de reasignar la variable <code>products</code> cada vez que añadimos una condición.  Se trata de un patrón común cuando trabajamos con parámetros de búsqueda y si se da mucho en nuestras aplicaciones deberíamos considerar la técnica que vamos a presentar, que nosotros hemos llamado el Delegador Dinámico.</p>

<p>En vez de explicar cómo funciona el delegador dinámico, veremos cómo podemos utilizar uno para refactorizar el código de nuestra búsqueda.  Empezaremos creando una clase de delegador dinámico en el directorio  <code>/lib</code> de nuestra aplicación.</p>

<p class="codeFilePath">/lib/dynamic_delegator.rb</p>
<pre class="ruby">
class DynamicDelegator
  def initialize(target)
    @target = target
  end  
  
  def method_missing(*args, &amp;block)
    @target.send(*args, &amp;block)
  end
end
</pre>

<p>La clase <code>DynamicDelegator</code> recibe un argumento en su inicializador, un objeto destino, y pone una variable local apuntando a dicho objeto.  También sobrecarga <code><a href="http://ruby-doc.org/core/classes/Kernel.html#M005925">method_missing</a></code>, por lo que cualquier llamada a este objeto que no esté soportada será enviada al objeto destino con los mismos argumentos y el mismo bloque (si lo hubiera).</p>

<p>Podemos ver nuestro <code>DynamicDelegator</code> como un objeto proxy que pasa cualquier método que sea invocado sobre él al objeto de destino, y esto significa que podemos usarlo donde queramos, así que podemos cambiar el objeto <code>scoped</code> en el método <code>search</code> del modelo <code>Product</code> por un <code>DynamicDelegator</code> que recibe dicho objeto como argumento.</p>

<p class="codeFilePath">/app/models/product.rb</p>
<pre class="ruby">
class Product &lt; ActiveRecord::Base
  belongs_to :category
  
  def self.search(params)
    products = DynamicDelegator(scoped)
    products = products.where(&quot;name like ?&quot;, &quot;%&quot; + params[:name] + &quot;%&quot;) if params[:name]
    products = products.where(&quot;price &gt;= ?&quot;, params[:price_gt]) if params[:price_gt]
    products = products.where(&quot;price &lt;= ?&quot;, params[:price_lt]) if params[:price_lt]    
    products
  end 

end
</pre>

<p>Se puede comprobar que esto funciona recargando la página y veremos los mismos resultados.</p>

<div class="imageWrapper">
  <img src="/system/photos/377/original/E212I01.png" width="800" height="315" alt="La página sigue funcionando."/>
</div>

<p>En este punto tal vez nos preguntemos el sentido de utilizar un <code>DynamicDelegator</code> en lugar del objeto <code>scoped</code>, y la ventaja del delegador es que podemos hacer lo que queramos dentro de  <code>method_missing</code>.  En lugar de delegar siempre al mismo objeto de destino podemos modificar dicho destino y hacerlo más dinámico.</p>

<p>Por ejemplo podríamos querer capturar el resultado de la llamado al método en <code>method_missing</code> y si devuelve un objeto de la misma clase que el objeto destino, hacer que el nuevo destino pase a ser el resultado.</p>

<p class="codeFilePath">/lib/dynamic_delegator.rb</p>
<pre class="ruby">
class DynamicDelegator
  def initialize(target)
    @target = target
  end  
  
  def method_missing(*args, &amp;block)
    result = @target.send(*args, &amp;block)
    @target = result if result.kind_of? @target.class
    result
  end
end
</pre>

<p>Con esto ya podemos quitar el código que reinicia la variable <code>products</code> en cada línea del método <code>search</code> en el modelo <code>Product</code>.</p>

<p class="codeFilePath">/app/models/product.rb</p>
<pre class="ruby">
class Product &lt; ActiveRecord::Base
  belongs_to :category
  
  def self.search(params)
    products = DynamicDelegator.new(scoped)
    products.where(&quot;name like ?&quot;, &quot;%&quot; + params[:name] + &quot;%&quot;) if params[:name]
    products.where(&quot;price &gt;= ?&quot;, params[:price_gt]) if params[:price_gt]
    products.where(&quot;price &lt;= ?&quot;, params[:price_lt]) if params[:price_lt]    
    products
  end 

end
</pre>

<p>Esto se puede hacer porque siempre que invoquemos el método <code>where</code> recibiremos un objeto del mismo tipo que <code>scoped</code> y por tanto el destino cambiará cada vez.  Recarguemos la página y veamos que sigue funcionando.</p>

<div class="imageWrapper">
  <img src="/system/photos/378/original/E212I02.png" width="800" height="315" alt="El delegador dinámico se devuelve a sí mismo en lugar de su objeto destino."/>
</div>

<p>No lo hace, y el motivo es que no estamos delegando todos los métodos a nuestro objeto de destino.  En este caso el problema es el método <code>class</code>, y veremos por qué en la consola.   Si invocamos <code>Product.search</code> con un <em>hash</em> vacío e invocamos  <code>class</code> sobre el resultado, veremos que recibimos <code>DynamicDelegator</code>.</p>

<pre class="terminal">
ruby-head &gt; Product.search({}).class
 =&gt; DynamicDelegator
</pre>

<p>Así que nuestro delegador dinámico no lo está delegando todo al objeto de destino, ya que tiene algunos métodos definidos sobre sí mismo.  Esto es debido a que la clase <code>DynamicDelegator</code> hereda de <code>Object</code> y <code>Object</code> tiene muchos métodos definidos, uno de los cuales es  <code>class</code>.</p>

<pre class="terminal">
ruby-head &gt; Object.instance_methods.count
 =&gt; 108 
ruby-head &gt; Object.instance_methods.grep /class/
 =&gt; [:subclasses_of, :class_eval, :class, :singleton_class]
</pre>

<p>Necesitamos algo más despejado sobre lo que basarnos, y en Ruby 1.9 existe otra clase que podemos usar, llamada <code>BasicObject</code> que tiene muchos menos métodos.</p>

<pre class="terminal">
ruby-head &gt; BasicObject.instance_methods
 =&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
</pre> 

<p>Esta clase es un mejor punto de partida para hacer objetos proxy o delegados que usen 
 <code>method_missing</code>.  Si cambiamos <code>DynamicDelegator</code> para que herede de <code>BasicObject</code> , el método <code>class</code> no estará definido y su invocación acabará pasando a través de <code>method_missing</code>.</p>

<p class="codeFilePath">/lib/dynamic_delegator.rb</p>
<pre class="ruby">
class DynamicDelegator &lt; BasicObject
  def initialize(target)
    @target = target
  end  
  
  def method_missing(*args, &amp;block)
    result = @target.send(*args, &amp;block)
    @target = result if result.kind_of? @target.class
    result
  end
end
</pre>

<p>Si recargamos la página, veremos que ahora sí que funciona.</p>

<div class="imageWrapper">
  <img src="/system/photos/377/original/E212I01.png" width="800" height="315" alt="La página vuelve a funcionar."/>
</div>

<p>Aún podemos llevar un poco más lejos la refactorización en el modelo <code>Product</code>. El delegador dinámico no expresa su intención con mucha claridad por lo que podríamos escribir un método en la clase <code>Product</code> llamado <code>scope_builder</code> en el que crear el <code>DynamicDelegator</code>.</p>

<p class="codeFilePath">/app/models/product.rb</p>
<pre class="ruby">
class Product &lt; ActiveRecord::Base
  belongs_to :category
  
  def self.search(params)
    products = scope_builder
    products.where(&quot;name like ?&quot;, &quot;%&quot; + params[:name] + &quot;%&quot;) if params[:name]
    products.where(&quot;price &gt;= ?&quot;, params[:price_gt]) if params[:price_gt]
    products.where(&quot;price &lt;= ?&quot;, params[:price_lt]) if params[:price_lt]    
    products
  end 
  
  def self.scope_builder
    DynamicDelegator.new(scoped)
  end

end
</pre>

<p>Ahora queda mucho más claro que estamos trabajando con un ámbito que estamos construyendo dinámicamente.  Si usamos esta técnica en varios modelos podríamos mover el método  <code>scope_builder</code> a <code>ActiveRecord::Base</code> para que esté disponible en todos los modelos.  Esto lo podríamos hacer en un archivo de inicialización.</p>

<p>Esto es todo por este episodio.  Esta técnica pueda parecer muy simple pero si estamos construyendo muchas consultas puede hacer que nuestro código quede mucho más limpio.</p>