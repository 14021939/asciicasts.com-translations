<p>One question that&rsquo;s asked quite frequently is how to create a form in a Rails application without a database table behind it. We&rsquo;ll show you how to do just that in this episode and to do so we&rsquo;ll use the blog application that we&rsquo;ve used in the previous couple of episodes.</p> 

<div class="imageWrapper">
  <img src="/system/photos/271/original/E193I01.png" width="815" height="400" alt="Our blog application."/>
</div>

<p>What we want to do is add a &ldquo;Share this article&rdquo; link on each article&rsquo;s page. This link will take a user the a form on which they can enter inormation so that they can share an article via email. We don&rsquo;t want to keep this information, just use it to send the email so how do we create a form and a model without a corresponding database table?</p>

<p>The approach we&rsquo;ll take will be to create a normal model with a database table behind it and then modify the application to remove the table. We&rsquo;ll start by generating a scaffold and for this we&rsquo;ll use Ryan Bates&rsquo; <a href="http://github.com/ryanb/nifty-generators">nifty scaffold generator</a>.</p>

<p>We have to create a new model as we&rsquo;ll be submitting a form and creating a new resource. We&rsquo;ll call the new model Recommendation as by emailing details about an article to someone we&rsquo;re recommending it to them. The Recommendation model will have fields to hold who the email is from and to, the id of the article that&rsquo;s being recommended and a field for a message. The related controller will need new and create actions. We can generate the scaffold with:</p>
<pre class="terminal">
script/generate nifty_scaffold recommendation from_email:string to_email:string article_id:integer message:text new create
</pre>
<p>Next we&rsquo;ll need to migrate the database to create the table, even though we don&rsquo;t actually want the table (we&rsquo;ll roll the migration back later).</p>
<pre class="terminal">
rake db:migrate
</pre>
<p>Now that we have a model and a controller we&rsquo;ll create a link to the <code>new</code> action in the <code>RecommendationController</code>, passing the <code>id</code> of the article that will be recommended.</p>
<pre class="terminal">
&lt;p&gt;
  &lt;%= link_to &quot;Share this article&quot;, new_recommendation_path(:article_id =&gt; @article.id) %&gt;
  &lt;%= link_to &quot;Back to Articles&quot;, articles_path %&gt;
&lt;/p&gt;
</pre>
<p class="title">Adding the recommendation link to <code>/app/views/articles/show.html.erb</code></p>

<p>Note that we need to pass the article&rsquo;s id from the link to the new <code>Recommendation</code> so that it stays referenced.</p>

<p>Next we&rsquo;ll move to the view that was generated by the scaffold and modify it to remove the <code>article_id</code> field and its label and replace them with a hidden field that holds the <code>article_id</code>.</p>
<pre class="ruby">
&lt;% title &quot;New Recommendation&quot; %&gt;
&lt;% form_for @recommendation do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;%= f.hidden_field :article_id %&gt;
  &lt;p&gt;
    &lt;%= f.label :from_email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :from_email %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :to_email %&gt;&lt;br /&gt;
    &lt;%= f.text_field :to_email %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :message %&gt;&lt;br /&gt;
    &lt;%= f.text_area :message %&gt;
  &lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;
&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, recommendations_path %&gt;&lt;/p&gt;
</pre>
<p class="title">Modifying <code>/app/views/recommendations/new.html.erb</code></p> 

<p>When we reload the article&rsquo;s page now the &ldquo;Share this article&rdquo; link will be visible and when we click on it we&rsquo;ll see the new form.</p>

<div class="imageWrapper">
  <img src="/system/photos/272/original/E193I02.png" width="800" height="478" alt="The new recommendation form."/>
</div>

<p>If we were to fill in this form and submit it we&rsquo;ll create a new recommendation in the database, but in this case we don&rsquo;t want to save this form to the database just send an email. In Rails applications the <code>create</code> action is generally used to save a new model to the database but there&rsquo;s nothing forcing us to do that. Instead we&rsquo;ll just check to see if the new <code>Recommendation</code> is valid.</p>
<pre class="ruby">
def create
  @recommendation = Recommendation.new(params[:recommendation])
  if @recommendation.valid?
    flash[:notice] = &quot;Successfully created recommendation.&quot;
    redirect_to @recommendation
  else
    render :action =&gt; &#x27;new&#x27;
  end
end
</pre>
<p>We&rsquo;ll roll back the last migration now to drop the recommendations table and see if our form works without it. We&rsquo;ll remove the migration file too.</p>
<pre class="terminal">
rm db/migrate/*_recommendations.rb
</pre>
<p>Without the database table removed we get an error when we reload the form, the application complaining, not surprisingly, that it can&rsquo;t find the recommendations table. This is because ActiveRecord relies on every model having an associated table.</p>

<div class="imageWrapper">
  <img src="/system/photos/273/original/E193I03.png" width="800" height="478" alt="The exception raised when we remove the table."/>
</div>

<p>So how are we going to create a model that doesn&rsquo;t have a database table behind it? There are several potential solutions including various plugins but we&rsquo;re going to use the method described in <a href="http://codetunes.com/2008/07/20/tableless-models-in-rails/">an entry on the Code Tunes blog</a>. This shows a techinque that involves overriding a couple of methods in an ActiveRecord model and then manually defining the columns in the model file rather than in the database table. In our <code>Recommendation</code> model we&rsquo;ll add in the two overridden methods and then use the <code>column</code> class method to define the columns in a similar way to how they&rsquo;re defined in a migration file.</p>
<pre class="ruby">
class Recommendation &lt; ActiveRecord::Base
  def self.columns() @columns ||= []; end
 
  def self.column(name, sql_type = nil, default = nil, null = true)
    columns &lt;&lt; ActiveRecord::ConnectionAdapters::Column.new(name.to_s, default, sql_type.to_s, null)
  end
  
  column :from_email, :string
  column :to_email, :string
  column :article_id, :string
  column :message, :text  
end
</pre>
<p class="title">Defining the columns in <code>/app/models/recommendation.rb</code></p>

<p>When we reload the new recommendation page now we&rsquo;ll see the form again instead of an error, but the columns are now defined in the model class rather than fetched from a database table.</p>

<p>You might be wondering why the recommendation class still inherits from <code>ActiveRecord::Base</code> when we&rsquo;re not using a database backend. We could quite easily create a model class that isn&rsquo;t based on ActiveRecord and have it work as Rails is quite decoupled from ActiveRecord, but there are advantages to keeping our model class inheriting from ActiveRecord. For one thing it means we can use its other features such as validations. We can then validate the format of the email addresses and the length of the message using ActiveRecord validations in the model.</p>
<pre class="ruby">
validates_format_of :from_email, :to_email, :with =&gt; /^[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}$/i
validates_length_of :message, :maximum =&gt; 500
</pre>
<p class="title">Adding validation to <code>/app/models/recommendation.rb
</code></p>
<p>With these validations added we&rsquo;ll see the same Rails error messages we&rsquo;d see if we had a normal database-backed model if we submit the form with invalid email addresses.</p>

<div class="imageWrapper">
  <img src="/system/photos/274/original/E193I04.png" width="797" height="364" alt="The validation errors are shown when the email addresses are invalid."/>
</div>

<p>Another reason to keep our tableless model inheriting from ActiveRecord is that we can still make use of associations. <code>Recommendation</code> has an <code>article_id</code> as one of its fields and so we can still use</p>
<pre class="ruby">
belongs_to :article
</pre>
<p>in the model so that we can still fetch the related <code>Article</code> object whenever we need it.</p>

<p>We now have an ActiveRecord model that behaves much like any other but which doesn&rsquo;t rely on a database backend as its columns are defined manually in Ruby. If we do accidentally call a method that hits the database and requires a database table we&rsquo;ll see the same exception raised that we saw earlier saying that the table doesn&rsquo;t exist and can work around it.</p>

<p>The one part of the application that remains to be done is the code that sends an email when the recommendation form has been fillled in correctly. We won&rsquo;t write that now as its out of the scope of this episode but if you want to know how it&rsquo;s done take a look at <a href="http://railscasts.com/episodes/61-sending-email">episode 61</a> which covers this topic.</p>

<p>While being able to create tableless models is a useful technique you should ask yourself whether you really don&rsquo;t want to store records in the database. It&rsquo;s so easy to store user-submitted data like this in a database table that there has to be a good reason not to do so even if you don&rsquo;t have any immediate use for it. If nothing else it serves as a backup if our emailing system fails.</p>