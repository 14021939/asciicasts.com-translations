<p>Cet épisode aborde les conditions de la méthode <code>find</code>. Ci-dessous, quelques lignes de <code>script/console</code>, affiché avec le SQL qu'elles génèrent.</p>
<code class="terminal">Task.find(:all, :conditions =&gt; ["completed = ? AND priority = ?", false, 2])</code>
<code class="sql">SELECT * FROM "tasks" WHERE (completed = 'f' AND priority = 2)</code>
<p class="title">Chercher toutes les tâches incomplètes avec une priorité de 2.</p>

<p>L'exemple ci-dessus fonctionne mais si nous cherchons les tâches qui ont une priorité qui vaut <code>nil</code> ?
<code class="terminal">Task.find(:all, :conditions =&gt; ["completed = ? AND priority = ?", false, nil])</code>
<code class="sql">SELECT * FROM "tasks" WHERE (completed = 'f' AND priority = NULL) </code>
<p class="title">Rechercher des valeurs nulles génère du <span class="caps">SQL</span> incorrect.</p>

<p>Le SQL généré ci-dessus est incorrect. Quand on recherche des valeurs nulles la syntaxe correcte serait <code>priority IS NULL</code>, pas <code>priority = NULL</code>. De la même façon, si nous recherchons plus d'une priorité en utilisant un tableau ou un ensemble défini nous devons changer la chaine de la méthode <code>find</code> pour utiliser <code>IN</code> plutôt que <code>=</code>, et mettre des parenthèses autour du deuxième point d'interrogation pour s'assurer que le SQL généré soit correct.</p>
<code class="terminal">Task.find(:all, :conditions =&gt; ["completed = ? AND priority IN (?)", false, [1,3]])</code>
<code class="sql">SELECT * FROM "tasks" WHERE (completed = 'f' AND priority IN (1,3))</code>

<p>Depuis Rails 1.2, il y a une meilleure façon de passer des conditions : en utilisant un hash. Utiliser un hash de conditions assure que Rails utilise les conditions correctes en interrogeant la base de données.</p>
<code class="terminal">Task.find(:all, :conditions =&gt; { :completed =&gt; false, priority =&gt; [1,3] }</code>
<code class="sql">SELECT * FROM "tasks" WHERE (completed = 'f' AND priority IN (1,3)</code>
<p class="title">Utilisation d'un hash de conditions avec un tableau comme paramètre.</p>

<code class="terminal">Task.find(:all, :conditions =&gt; {:completed =&gt; false, priority =&gt; 2..4})</code><code class="sql">SELECT * FROM "tasks" WHERE ("tasks"."priority" BETWEEN 2 AND 4 AND "tasks"."completed" = 'f') </code>
<p class="title">Donner un ensemble de chiffres et <code>BETWEEN</code> sera utilisé dans le <span class="caps">SQL</span>.</p>

<h3>Utilisation avec des finds dynamiques</h3>
<p>Dans l'<a href="/episodes/2-methode-dynamique-find-by">épisode 2</a>, nous utilisions des méthodes <code>find_by</code> dynamiques. Elles peuvent aussi prendre des arguments <code>nil</code>, <code>array</code> ou des espaces de nombres.</p>
<code class="terminal">Task.find_by_priority(1..5)</code><code class="sql">SELECT * FROM "tasks" WHERE ("tasks"."priority" BETWEEN 1 AND 5) LIMIT 1</code>

<p>En utilisant un hash de conditions, nous nous assurons que Rails génère le <span class="caps">SQL</span> correctement quelques soient les arguments qu'on lui donne.</p>