<p>Esta semana tenemos un episodio un poco diferente.  Vamos a bucear en la implementación de Rails 3 para echar un vistazo a parte de su código, concretamente el código que se encarga del enrutamiento.  A continuación se muestra el fichero de rutas de la aplicación de tienda del último episodio.  Veremos el código real de Rails que se ejecuta para comprender su funcionamiento con todo detalle.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  resources :products do
    resources :reviews
  end
  root :to =&gt; &quot;products#index&quot;
end
</pre>

<p>Cabría preguntarse si tiene sentido o merece la pena esto de leer código ajeno, pero en nuestra opinión leer código escrito por otros es una magnífica manera de mejorar nuestro nivel de Ruby.   Veremos trucos y técnicas usadas por otros que aprenderemos a usar en nuestro propio código.  Además, leer el código fuente de Rails también nos servirá para aprender a hacer un mejor uso de Rails, en este caso veremos formas de escribir mejor los archivos de rutas.  Nos será también útil si algún día intentamos depurar un problema u optimizar nuestro código o incluso si consideramos colaborar algún día con el desarrollo de Rails.</p>

<h3>Empezando</h3>

<p>En este episodio se asumirá que el lector conoce el funcionamiento de las rutas en Rails 3.  Si no es el caso, o como refresco, se puede visitar primero el episodio 203 [<a href="http://railscasts.com/episodes/203-routing-in-rails-3">verlo</a> or <a href="http://es.asciicasts.com/episodes/203-rutas-en-rails-3">leerlo</a>] porque la sintaxis de las rutas es distinta a la de Rails 2</p>

<p>El código fuente de Rails está alojado en <a href="http://github.com/rails/rails">Github</a> por lo que es muy fácil clonar el repositorio para poder hojearlo.  Tan sólo tenemos que ejecutar</p>
<head><base href='http://es.asciicasts.com'></head>

<pre class="terminal">
$ git clone git://github.com/rails/rails.git
</pre>

<p>La rama maestra del repositorio que hemos descargado es la de Rails 3.1, que es la versión en desarrollo actualmente. Como queremos ver la misma versión de Rails que está ejecutando nuestra aplicación vamos a cambiar a la versión etiquetada como 3.0.0 ejecutando</p>


<pre class="terminal">
$ git checkout v3.0.0
</pre>

<p>Veremos que Rails está compuesto de varios componentes separados.  Cualquier cosa que tenga que ver con los controladores, vistas y rutas se encontrará alojada en el directorio <code>actionpack</code>.</p>

<div class="imageWrapper">
  <img src="/system/photos/472/original/E231I01.png" width="795" height="454" alt="La estructura de directorios del código fuente de Rails."/>
</div>

<p>Dentro de <code>actionpack</code> el código relacionado con las rutas se encuentra en el directorio <code>lib/action_dispatch</code>.</p>

<div class="imageWrapper">
  <img src="/system/photos/473/original/E231I02.png?1284930544" width="796" height="540" alt="Estructura de directorio de actionpack mostrando los archivos de implementación de las rutas."/>
</div>

<h3>Los métodos <code>routes</code> y <code>draw</code>.</h3>

<p>Antes de empezar a leer el código de Rails volvamos a nuestra aplicación y repasemos una vez más el fichero de rutas.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  resources :products do
    resources :reviews
  end
  root :to =&gt; &quot;products#index&quot;
end
</pre>


<p>La primera línea de código invoca el método <code>routes</code> sobre <code>Store::Application</code>, donde <code>Store</code> es el nombre de la aplicación. En el archivo <code>application.rb</code> podremos ver que es ahí donde se define el nombre de la aplicación.</p>

<p class="codeFilePath">/config/application.rb</p>
<pre class="ruby">
require File.expand_path(&#x27;../boot&#x27;, __FILE__)

require &#x27;rails/all&#x27;

# If you have a Gemfile, require the gems listed there, including any gems
# you&#x27;ve limited to :test, :development, or :production.
Bundler.require(:default, Rails.env) if defined?(Bundler)

module Store
  class Application &lt; Rails::Application
     # Configure sensitive parameters which will be filtered from the log file.
    config.filter_parameters += [:password]
  end
end
</pre>

<p>La clase <code>Store::Application</code> es donde tiene lugar la mayor parte de la configuración de la aplicación y hereda de <code>Rails::Application</code>.  Cualquier cosa con el prefijo <code>Rails</code>  se encuentra por lo general definida en el directorio <code>railties</code> del código fuente de RAils; el código de la clase <code>Rails::Application</code> se encuentra en  <code>rails/railties/lib/rails/application.rb</code>, donde podremos encontra el método <code>routes</code>.</p>

<p class="codeFilePath">rails/railties/lib/rails/application.rb</p>
<pre class="ruby">
def routes
  @routes ||= ActionDispatch::Routing::RouteSet.new
end
</pre>

<p>Este es el método que se ejecuta desde el fichero de rutas de la aplicación, y su única misión es crear un nuevo objeto  <code>ActionDispatch::Routing::RouteSet</code>.  El método <code>routes</code> devuelve este  <code>RouteSet</code>, sobre el que se invocará el método <code>draw</code> en la primera línea de nuestro archivo de rutas.  Este método se puede encontrar en la definición de la clase.  Pr lo general en el código fuente de Rails las clases se encuentran definidas en archivos con un nombre similar y la clase <code>RouteSet</code> no es una excepción.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/route_set.rb</p>
<pre class="ruby">
def draw(&amp;block)
  clear! unless @disable_clear_and_finalize

  mapper = Mapper.new(self)
  if block.arity == 1
    mapper.instance_exec(DeprecatedMapper.new(self), &amp;block)
  else
    mapper.instance_exec(&amp;block)
  end

   finalize! unless @disable_clear_and_finalize

   nil
end
</pre>

<p>El método <code>draw</code> recibe un bloque como argumento.  En primer lugar despeja cualquier ruta previamente existente y luego crea un nuevo objeto <code>Mapper</code>, pasándole <code>self</code> (el <code>RouteSet</code>) --dentro de poco veremos la clase <code>Mapper</code>--.  El método luego comprueba el número de argumentos del bloque, si recibe al menos un argumento entonces quiere decir que el fichero de rutas está usando la sintaxis de Rails 2.  Esto se hace para que la aplicación pueda funcionar definiendo rutas al estilo de Rails 2, donde el bloque tomaba como argumento un parámetro <code>map</code>:</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do |map|
  # Rails 2 routes...
end
</pre>

<p>Independientemente de que nuestra aplicación use rutas al estilo de Rails 2 o Rails 3 lo siguiente que hace es llamar a <code>instance_exec</code>.  Si la aplicación usaba las rutas del estilo de Rails 2 se genera un objeto <code>DeprecatedMapper</code> para pasárselo a <code>instance_exec</code>, mientras que si usa el estilo de rutas de Rails 3 se pasará directamente el bloque.  <code>instance_exec</code> ejecutará el bloque exatamente igual que si estuviera dentro de la instancia lo que significa que dentro de un fichero de rutas cualquier cosa que escribamos se eejcuta dentro de un objeto <code>Mapper</code>, que nos proporciona el útil lenguaje de rutas de Rails 3 donde podemos invocar a métodos como <code>resources</code> sin tener que invocarlos sobre objetos específicos como en Rails 2 (donde usábamos <code>map.resources</code>).</p>

<p>La último que hace el método <code>draw</code> es invocar el método <code>finalize!</code> que se define un poco más adelante en la clase <code>RouteSet</code> para congelar el conjunto de rutas.</p>

<h3>Cómo se mapean las rutas</h3>

<p>Ahora que ya sabemos que todo lo que está dentro del archivo de rutas de Rails 3 se ejecuta contra un objeto <code>Mapper</code> vamos a usar una ruta sencilla como ejemplo para ver cómo es procesada.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  match &#x27;products&#x27;, :to =&gt; &#x27;products#index&#x27;
end
</pre>

<p>Veamos lo que hace el método <code>match</code> de la clase <code>Mapper</code>.  Nos encontramos con varios métodos llamados <code>match</code> en dicha clase; el que nos interesa se encuentra en el módulo <code>Base</code>.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
module Base
  def initialize(set) #:nodoc:
    @set = set
  end

  def root(options = {})
    match &#x27;/&#x27;, options.reverse_merge(:as =&gt; :root)
  end

  def match(path, options=nil)
    mapping = Mapping.new(@set, @scope, path, options || {}).to_route
    @set.add_route(*mapping)
    self
  end

  # other methods

end
</pre>

<p>Para crear un nuevo objeto <code>Mapper</code> tenemos que pasar un <code>RouteSet</code>.  Cuando se invoca el método <code>match</code> en el fichero de rutas para crear una nueva ruta dicha ruta se añade al <code>RouteSet</code>, creando un nuevo objeto <code>Mapping</code> y luego ejecutándose <code>to_route</code> sobre él.  Nótese también que el método <code>root</code> es realmente sencillo, tan sólo llama a <code>match</code> pasando la raíz URL y añadiendo la opción <code>:as =&gt; :root</code> para que sea una ruta con nombre. 
	
<p>Veamos a continuación la clase <code>Mapping</code>, que está contenido en el mismo fichero <code>mapper.rb</code>.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
class Mapping #:nodoc:
  IGNORE_OPTIONS = [:to, :as, :via, :on, :constraints, :defaults, :only, :except, :anchor, :shallow, :shallow_path, :shallow_prefix]

  def initialize(set, scope, path, options)
    @set, @scope = set, scope
    @options = (@scope[:options] || {}).merge(options)
    @path = normalize_path(path)
    normalize_options!
  end

  def to_route
    [ app, conditions, requirements, defaults, @options[:as], @options[:anchor] ]
  end

  private 

  def normalize_options!
    path_without_format = @path.sub(/\(\.:format\)$/, &#x27;&#x27;)

    if using_match_shorthand?(path_without_format, @options)
      to_shorthand    = @options[:to].blank?
      @options[:to] ||= path_without_format[1..-1].sub(%r{/([^/]*)$}, &#x27;#\1&#x27;)
      @options[:as] ||= Mapper.normalize_name(path_without_format)
    end

    @options.merge!(default_controller_and_action(to_shorthand))
  end

  # other private methods omitted.

end
</pre>

<p>Durante su inicialización, algunas variables de instancia del <code>Mapper</code> se establecen a partir de los parámetros recibidos, y luego se invoca a <code>normalize_options!</code>.  Este método comprueba si estamos usando la sintaxis abreviada en la ruta y en el método <code>using_match_shorthand?</code> nos encontramos con un truco intereante.  Hay una forma abreviada de definir acciones de controlador, donde basta con separar el nombre y la acción por una barra inclinada.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
# match &quot;account/overview&quot;
def using_match_shorthand?(path, options)
  path &amp;&amp; options.except(:via, :anchor, :to, :as).empty? &amp;&amp; path =~ %r{^/[\w\/]+$}
end
</pre>

<p>Si hemos definido así la ruta las opciones <code>:to</code> y <code>:as</code> se establecerán automáticamente dependiendo del nombre de la URL.  Veamos esto en el archivo de rutas de nuestra aplicación añadiendo otra ruta que utiliza esta sintaxis abreviada:</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  match &#x27;products&#x27;, :to =&gt; &#x27;products#index&#x27;
  match &#x27;products/recent&#x27;, :to =&gt; &#x27;products#recent&#x27;
end
</pre>

<p>Hemos pasado el parámetro <cdoe>:to</cdoe> a esta nueva ruta pero si lo omitimos será rellenadoautomáticamente.  Este método automáticamente añadirá el parámetro <code>:as</code> como si hubiésemos escrito <code>:as =&gt; products_recent</code>.</p>

<h3>Cómo se usa Rack en las rutas</h3>

<p>En el método <code>match</code>, una vez que hemos creado un nuevo objeto <code>Mapping</code> invocamos al método <code>to_route</code> sobre él.  Este método devuelve un <em>array</em> de opciones que son las que se utilizan para crear la nueva ruta.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def to_route
  [ app, conditions, requirements, defaults, @options[:as], @options[:anchor] ]
end
</pre>

<p>Los primeros cuatro elementos del <em>array</em> son valores recibidos de llamadas a métodos en la clase <code>Mapper</code>.</p>


<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def app
  Constraints.new(
    to.respond_to?(:call) ? to : Routing::RouteSet::Dispatcher.new(:defaults =&gt; defaults),
    blocks,
    @set.request_class
  )
end

def conditions
  { :path_info =&gt; @path }.merge(constraints).merge(request_method_condition)
end

def requirements
  @requirements ||= (@options[:constraints].is_a?(Hash) ? @options[:constraints] : {}).tap do |requirements|
    requirements.reverse_merge!(@scope[:constraints]) if @scope[:constraints]
    @options.each { |k, v| requirements[k] = v if v.is_a?(Regexp) }
   end
end

def defaults
  @defaults ||= (@options[:defaults] || {}).tap do |defaults|
    defaults.reverse_merge!(@scope[:defaults]) if @scope[:defaults]
    @options.each { |k, v| defaults[k] = v unless v.is_a?(Regexp) || IGNORE_OPTIONS.include?(k.to_sym) }
  end
end
</pre>

<p>La primera opción es <code>app</code>, y cuando veamos en el código fuente de Rails algo llamado <code>app</code> es muy probable que se refiere a una aplicación Rack.  Este método <code>app</code> devuelve un nuevo objeto <code>Constraints</code>, así que veamos si se trata de una aplicación Rack.</p>

<p>La clase <code>Constraints</code> está definida en el mismo archivo <code>mapper.rb</code>.  Recibe varios métodos, uno d elos cuales se llama <code>call</code> y recibe como parámetro un entorno.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def call(env)
  req = @request.new(env)

  @constraints.each { |constraint|
    if constraint.respond_to?(:matches?) &amp;&amp; !constraint.matches?(req)
      return [ 404, {&#x27;X-Cascade&#x27; =&gt; &#x27;pass&#x27;}, [] ]
    elsif constraint.respond_to?(:call) &amp;&amp; !constraint.call(*constraint_args(constraint, req))
      return [ 404, {&#x27;X-Cascade&#x27; =&gt; &#x27;pass&#x27;}, [] ]
    end
  }

  @app.call(env)
end
</pre>

<p>La clase <code>Constraints</code> desde luego tiene toda la pinta de ser una aplicación Rack.  Como detalle interesante esta clase redefine el método <code>self.new</code> y cabría preguntarse por qué hace esto cuando tiene su propio método <code>initialize</code>.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def self.new(app, constraints, request = Rack::Request)
  if constraints.any?
    super(app, constraints, request)
  else
    app
  end
end

attr_reader :app

def initialize(app, constraints, request)
  @app, @constraints, @request = app, constraints, request
end
</pre>

<p>El motivo es el rendimiento.  <code>Constraints</code> es un <em>middleware</em> de Rack, o lo que es lo mismo, es un envoltorio de otra aplicación Rack.  El primer argumento que recibe <code>self.new</code> es <code>app</code>, que es una aplicación Rack y cuando se invoca el método <code>call</code> si se cumple cualquiera de las restricciones devolverá un <code>404</code> y en otro caso invocará a la aplicación Rack que está envolviendo.  El método <code>self.new</code> es un pequeño truco de rendimiento para que cuando se llame no sea necesario reservar espacio para otro objeto en memoria, envolverlo y utilizarlo, en su lugar simplemente devolverá la misma aplicación inicial Rack.</p>

<p>Volvamos al código que invoca esto.  Nótese que los dos primeros argumentos son una aplicación Rack y un <em>array</em> de restricciones, y se le llama desde el método <code>app</code> de la clase <code>Mapping</code>.  Cuando se crea una nuva restricción simplemente tenemos que ver si el método responde a <code>call</code> (el método <code>to</code> simplemente devuelve la ocpión <code>:to</code> que se definió para la ruta) si lo hace entonces es una aplicación Rack y podemos pasarla directamente, de lo contrario creo un nuevo objeto <code>RouteSet::Dispatcher</code> con ciertas opciones por defecto.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def app
  Constraints.new(
    to.respond_to?(:call) ? to : Routing::RouteSet::Dispatcher.new(:defaults =&gt; defaults),
    blocks,
    @set.request_class
  )
end
</pre>

<p>Este es el código que nos da la posibilidad de pasar una aplicación Rack a una ruta de esta manera:</p>


<pre class="ruby">
&nbsp;&nbsp;root&nbsp;:to&nbsp;=&gt;&nbsp;proc&nbsp;{&nbsp;|env|&nbsp;[200,&nbsp;{},&nbsp;[&quot;Welcome&quot;]]&nbsp;}
</pre>

<p>Poder usar Rack en combinación con las rutas de Rails nos da una gran flexibilidad, se trata este tema en más profundidad en el episodio 222
 [<a href="http://railscasts.com/episodes/222-rack-in-rails-3">verlo</a>, <a href="http://es.asciicasts.com/episodes/222-rack-y-rails-3">leerlo</a>]. </p>

<p>Si no le pasamos una aplicación Rack a la opción <code>:to</code> se creará un nuevo objeto de tipo <code>RouteSet::Dispatcher</code>.  A continuación veremos cómo se gestiona esto.</p>

<p>La clase <code>Dispatcher</code> gestiona el paso de la petición al controlador adecuado.  En el método <code>controller_reference</code> se puede ver el código donde se determina cuál es dicho controlador.</p>
 
<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/route_set.rb</p>
<pre class="ruby">
def controller_reference(controller_param)
  unless controller = @controllers[controller_param]
    controller_name = &quot;#{controller_param.camelize}Controller&quot;
    controller = @controllers[controller_param] =
       ActiveSupport::Dependencies.ref(controller_name)
  end
  controller.get
end
</pre>

<p>La clase también tiene métodos para hacer cosas como establecer la acción por defecto para que sea <code>index</code> si no viene especificada ninguna acción y un método <code>dispatch</code> que llama a la acción propiamente dicha y que devuelve una aplicación Rack.  Lo que esto quiere decir es que podemos coger cualquiera de los controladores de nuestra aplicación, invocar <code>action</code> sobre él pasándole el nombre de la acción que queramos y obtendremos de vuelta una aplicación Rack.</p>

<pre class="terminal">
ruby-1.9.2-p0 &gt; ProductsController.action(&quot;index&quot;)
 =&gt; #&lt;Proc:0x00000100ec56c0@/Users/eifion/.rvm/gems/ruby-1.9.2-p0/gems/actionpack-3.0.0/lib/action_controller/metal.rb:172&gt;
</pre> 

<p>Esto es lo que ocurre entre bambalinas cuando pasamos una ruta como esta</p>

<pre class="ruby">
match &#x27;products&#x27;, :to =&gt; &#x27;products#index&#x27;
</pre>

<p>La cadena <code>products#index</code> se transforma en <code>ProductsController.action(&quote;index&quote;)</code>, lo que devuelve una aplicación Rack.  La sintaxis de la cadena es un simple atajo de hacer lo mismo.</p>

<p>Hay mucha más que tratar acerca de las rutas que podríamos repasar: los métodos <code>resources</code> que generan varias rutas de una vez, los métodos que nos permiten definiri ámbitos y pasarles bloques... esperamos que eso sea suficiente para servir de acicate para leer el código de las rutas.</p>

<p>Las rutas probablemente sean una de las áreas más complejas de Rails, por lo que si nos intimida la complejidad del código visto aquí no hay que preocuparse: es un código difícil.  Es recomendable empezar primero por otras partes del código de Rails antes de enfrentarse a las partes más complejas.</p>
