<p>A multistep form, also known as a wizard, is a large form that has been split up into a series of pages that users can navigate through to complete the form. Not everyone is a fan of this approach, some people prefer to show one large form or to split a long form up into separate resources and models. There are, however, some cases when this is the best approach, for example an online tax return that requires a lot of user input and branching of steps and therefore makes sense to implement as a multistep form.</p>

<p>A good multistep form remembers the input between steps, allowing users to go backwards and forwards through the pages without losing any of the information they have entered. If you just want to break up a big form to simplify the user interface you may could use a combination of JavaScript and CSS to show and hide different parts of the form when the &ldquo;previous&rdquo; and &ldquo;next&rdquo; buttons are pressed. An <a href="http://developer.apple.com/internet/webcontent/examples/wizard.html">example of this approach</a> can be found of Apple&rsquo;s developer site. If you need something more dynamic and server-side orientated then you&rsquo;ll need to go through Rails itself and we&rsquo;ll show you how to do that in this episode.</p>

<h3>A Multistep Order Form</h3>

<p>To demonstrate a multistep form we&rsquo;re going to add a checkout process to a store application. Users will first fill in their shipping information and then their billing information and finally, on the third step, see a summary of their order where they can confirm it.</p>

<p>We don&rsquo;t have an order model or controller yet so we&rsquo;ll use one of Ryan Bates&rsquo; <a href="http://github.com/ryanb/nifty-generators">nifty generators</a> to create a scaffold for the order form. Note that this application is written in Rails 2 so we can use <code>script/generate</code>. A real order model would have many attributes, but for the purposes of this example we&rsquo;ll just have two. We&rsquo;ll also create <code>index</code>, <code>show</code> and <code>new</code> actions for the controller.</p>

<pre class="terminal">
$ script/generate nifty_scaffold order shipping_name:string billing_name:string index show new
</pre>

<p>Then we&rsquo;ll migrate the database to create the new database table.</p>

<pre class="terminal">
$ rake db:migrate
</pre>

<p>The order form as generated by the scaffold has all the fields together on one page so the first thing we need to do is to split it up into multiple steps.</p>

<div class="imageWrapper">
  <img src="/system/photos/391/original/E217I01.png" width="800" height="387" alt="The scaffold-generated new order form."/>
</div>

<p>The code for the new order form has all of the form fields together. To begin to make our multistep form we&rsquo;ll move each of the three paragraph elements and the form fields they wrap out into a separate partial.</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="ruby">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;p&gt;
    &lt;%= f.label :shipping_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :shipping_name %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :billing_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :billing_name %&gt;
  &lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>Before we do that, though we&rsquo;ll add a heading to each section and alter the final section so that it shows a summary of the order.</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="ruby">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;h2&gt;Shipping Information&lt;/h2&gt;
  &lt;p&gt;
    &lt;%= f.label :shipping_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :shipping_name %&gt;
  &lt;/p&gt;
  &lt;h2&gt;Billing Information&lt;/h2&gt;
  &lt;p&gt;
    &lt;%= f.label :billing_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :billing_name %&gt;
  &lt;/p&gt;
  &lt;h2&gt;Confirm Information&lt;/h2&gt;
  &lt;p&gt;
    &lt;strong&gt;Shipping Name:&lt;/strong&gt;
    &lt;%= h @order.shipping_name %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;strong&gt;Billing Name:&lt;/strong&gt;
    &lt;%= h @order.billing_name %&gt;
  &lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>With that done we can now move each section into its own partial. We&rsquo;ll create three new partials called shipping_step, billing_step and confirmation_step and copy the relevant parts of the form into them. After doing that our new order form will look like this:</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="terminal">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;%= render &#x27;shipping_step&#x27;, :f =&gt; f %&gt;
  &lt;%= render &#x27;billing_step&#x27;, :f =&gt; f %&gt;
  &lt;%= render &#x27;confirmation_step&#x27;, :f =&gt; f %&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>And the three partials will look like this:</p>

<p class="codeFilePath">/app/views/orders/_billing_step.html.erb</p>
<pre class="ruby">
&lt;h2&gt;Billing Information&lt;/h2&gt;
&lt;p&gt;
  &lt;%= f.label :billing_name %&gt;&lt;br /&gt;
  &lt;%= f.text_field :billing_name %&gt;
&lt;/p&gt;
</pre>

<p class="codeFilePath">/app/views/orders/_shipping_step.html.erb</p>
<pre class="ruby">
&lt;h2&gt;Shipping Information&lt;/h2&gt;
&lt;p&gt;
  &lt;%= f.label :shipping_name %&gt;&lt;br /&gt;
  &lt;%= f.text_field :shipping_name %&gt;
&lt;/p&gt;
</pre>

<p class="codeFilePath">/app/views/orders/confirmation_step.html.erb</p>
<pre class="ruby">
&lt;h2&gt;Confirm Information&lt;/h2&gt;
&lt;p&gt;
  &lt;strong&gt;Shipping Name:&lt;/strong&gt;
  &lt;%= h @order.shipping_name %&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;strong&gt;Billing Name:&lt;/strong&gt;
  &lt;%= h @order.billing_name %&gt;
&lt;/p&gt;
</pre>

<p>We&rsquo;ll need to make a change to the <code>Order</code> model so that it knows about each step and can identify which one is the current step. We could use a state machine plugin for doing this, but as this example is fairly simple we&rsquo;ll write the code from scratch.</p>

<p>The <code>Order</code> model will need to know what the steps are and the order they should be in and so we&rsquo;ll write a new steps method to return a list of the steps. Our list will be a simple array but for more complex forms this method easily be more dynamic and handle cases where the list of steps changes depending on how a give step was answered.</p>

<p>To get and set the current step for an order we&rsquo;ll create a writer called <code>current_step</code> and an equivalent accessor method that will return the current step if this has been set or the first step otherwise. After making these changes the <code>Order</code> model will look like this:</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
class Order &lt; ActiveRecord::Base
  attr_accessible :shipping_name, :billing_name
  attr_writer :current_step
  
  def current_step
    @current_step || steps.first
  end
  
  def steps
    %w[shipping billing confirmation]
  end
end
</pre>

<p>Now that the <code>Order</code> model knows which step is the current one we can use that information to dynamically change the partial that is rendered by modifying the new order form slightly so that it only shows the current step.</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="ruby">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;%= render &quot;#{@order.current_step}_step&quot;, :f =&gt; f %&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Submit&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>When we reload the order form now we&rsquo;ll see just the first step rendered.</p>

<div class="imageWrapper">
  <img src="/system/photos/392/original/E217I02.png" width="800" height="373" alt="The order form now only shows the first step."/>
</div>

<h3>Moving Through The Steps</h3>

<p>If we click the submit button on the form it will call the <code>create</code> action and create a new order but that isn&rsquo;t what we want to happen. Instead the next step of the form should be rendered and we&rsquo;ll need to change the controller&rsquo;s behaviour so that it does that.</p>

<p>There are a number of ways we can approach this problem. We could create a separate action for each of the steps; we could just use the <code>create</code> action for the initial step and the <code>edit</code> and <code>update</code> actions for the other steps which would mean that we have a partially-completed model in the database or we could stay in the <code>new</code> and <code>create</code> actions and store the details that have been entered so far in the session. There are some downsides to this approach and we&rsquo;ll mention these and show the alternatives as we go along.</p>

<p>The simplest thing we can do that would work is to modify the <code>create</code> action. The first step we&rsquo;ll take will be to change it so that it doesn&rsquo;t save the order but instead shows the next step of the form.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  @order = Order.new(params[:order])
  @order.next_step
  render &#x27;new&#x27;
end
</pre>

<p>In the controller we&rsquo;re calling a <code>next_step</code> method on <code>Order</code> that we&rsquo;ll have to write in the model code.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
def next_step
  self.current_step = steps[steps.index(current_step)+1]
end
</pre>

<p>Now we&rsquo;ll be taken from the first step to the second when we click the submit button on the form but when we click the button again we&rsquo;ll remain on the second step. This is because we&rsquo;re not recording the current step when the form is submitted. In the <code>create</code> action we need to set the current step in the <code>Order</code> model and then save that value. We can do this by getting the current step from the session, moving to the next one and then storing the next step back in the session.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  @order = Order.new(params[:order])
  @order.current_step = session[:order_step]
  @order.next_step
  session[:order_step] = @order.current_step
  render &#x27;new&#x27;
end
</pre>

<p>When we try the form now it will step through the pages as it should and wrap back round to the first step when we submit the final step. This isn&rsquo;t quite what we&rsquo;re after but we&rsquo;ll write the code to handle the final step later.</p>

<p>Before we do that, we&rsquo;ll implement a way to go back through the steps. The form currently allows us to move forward but we can&rsquo;t go back and make changes to the fields we&rsquo;ve already completed. We&rsquo;ll add another button to the form so that we can do that.</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="ruby">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;%= render &quot;#{@order.current_step}_step&quot;, :f =&gt; f %&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Continue&quot; %&gt;&lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Back&quot;, :name =&gt; &quot;previous_button&quot; %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>Note that we&rsquo;ve given the back button a <code>name</code> attribute so that we can determine which button was used to submit the form. We can now modify the controller to behave appropriately depending on which button was pressed.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  @order = Order.new(params[:order])
  @order.current_step = session[:order_step]
  if params[:back_button]
    @order.previous_step
  else
    @order.next_step
  end
  session[:order_step] = @order.current_step
  render &#x27;new&#x27;
end
</pre>

<p>For this to work we&rsquo;ll need a <code>previous_step</code> method in the <code>Order</code> model which will be similar to the <code>next_step</code> method we wrote before.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
def previous_step
  self.current_step = steps[steps.index(current_step)-1]
end
</pre>

<p>We now have buttons on the form that move us through the steps in both directions.</p>

<div class="imageWrapper">
  <img src="/system/photos/393/original/E217I03.png" width="800" height="410" alt="The form now has buttons for moving forwards and backwards."/>
</div>

<p>Having a back button on the first page doesn&rsquo;t make sense so we&rsquo;ll hide it if the order is on the first step.</p>

<p class="codeFilePath">/app/views/orders/new.html.erb</p>
<pre class="ruby">
&lt;% title &quot;New Order&quot; %&gt;

&lt;% form_for @order do |f| %&gt;
  &lt;%= f.error_messages %&gt;
  &lt;%= render &quot;#{@order.current_step}_step&quot;, :f =&gt; f %&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Continue&quot; %&gt;&lt;/p&gt;
  &lt;p&gt;&lt;%= f.submit &quot;Back&quot;, :name =&gt; &quot;previous_button&quot; unless @order.first_step? %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;p&gt;&lt;%= link_to &quot;Back to List&quot;, orders_path %&gt;&lt;/p&gt;
</pre>

<p>For this to work we&rsquo;ll have to add a <code>first_step?</code> method to the <code>Order</code> model.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
def first_step?
  current_step == steps.first
end
</pre>

<p>When we reload the form now and we won&rsquo;t have a back button on the first step.</p>

<div class="imageWrapper">
  <img src="/system/photos/394/original/E217I04.png" width="800" height="375" alt="The first step no longer has a back button"/>
</div>

<h3>Making Fields Remember Their Values</h3>

<p>We can now step backwards and forwards through our form but if we enter a value in one of the fields it isn&rsquo;t remembered if we go back to that step later. We can solve this problem by using the session again. While it isn&rsquo;t recommended to store complex objects in session variables, simple objects such as hashes and arrays are fine.</p> 

<p>The first step to doing this is to create a new session variable in the <code>new</code> action called <code>order_params</code> and to set its value to an empty hash unless it already exists.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def new
  session[:order_params] ||= {}
  @order = Order.new
end
</pre>

<p>In the <code>create</code> action we&rsquo;ll merge the values in the order parameters with the values from the session variable. Note that we&rsquo;re using a deep merge in case there are any nested values in the order parameters and only performing the merge if the order parameters exist. We can then create the new <code>Order</code> object from this merged hash.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  session[:order_params].deep_merge!(params[:order]) if params[:order]
  @order = Order.new(session[:order_params])
  @order.current_step = session[:order_step]
  if params[:back_button]
    @order.previous_step
  else
    @order.next_step
  end
  session[:order_step] = @order.current_step
  render &#x27;new&#x27;
end
</pre>

<p>Now when we fill in the form we&rsquo;ll see the values we entered on the final step, showing that they are stored between steps.</p>

<div class="imageWrapper">
  <img src="/system/photos/395/original/E217I05.png" width="804" height="419" alt="The final step of the form showing the saved information."/>
</div>

<p>There is still a slight problem, however. If we move away from the form while it is partially completed and then go back to it afterwards the information we entered and the step we were on are lost. We can solve this by copying the two lines that get the order information and current step from the session variables we created from the create action to new.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def new
  session[:order_params] ||= {}
  @order = Order.new(session[:order_params])
  @order.current_step = session[:order_step]
end
</pre>

<p>With this code in place we can now return to the form and any data we&rsquo;ve entered will still be there. Not only that but we&rsquo;ll be taken straight to the last step we were on.</p>

<h3>Saving an Order</h3>

<p>Now we&rsquo;ll make the form fully-functional by making it save the order when the last step is completed. We can do this by modifying the controller so that it saves the order only if the current step is the last one and if the button pressed wasn&rsquo;t the &ldquo;previous step&rdquo; button. We&rsquo;ll also need to change the rendering behaviour so that if the order is saved the application redirects to the order&rsquo;s show action and displays a flash message.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
class OrdersController &lt; ApplicationController
  def index
    @orders = Order.all
  end
  
  def show
    @order = Order.find(params[:id])
  end
  
  def new
    session[:order_params] ||= {}
    @order = Order.new(session[:order_params])
    @order.current_step = session[:order_step]
  end
  
  def create
    session[:order_params].deep_merge!(params[:order]) if params[:order]
    @order = Order.new(session[:order_params])
    @order.current_step = session[:order_step]
    if params[:back_button]
      @order.previous_step
    elsif @order.last_step?
      @order.save
    else
      @order.next_step
    end
    session[:order_step] = @order.current_step
    
    if @order.new_record?
      render &#x27;new&#x27;
    else
      flash[:notice] = &quot;Order saved.&quot;
      redirect_to @order
    end
  end
end
</pre>

<p>To make this work we&rsquo;ll also have to add a <code>last_step</code> method to the <code>Order</code> model.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
def last_step?
  current_step == steps.last
end
</pre>

<p>When we go the form now and fill in each step the order will be saved and we&rsquo;ll be redirected to the page for that order.</p>

<div class="imageWrapper">
  <img src="/system/photos/396/original/E217I06.png" width="801" height="343" alt="The order has been saved."/>
</div>

<p>We&rsquo;re not quite there yet, though. If we try to create another new order the form will go straight to the final step and we&rsquo;ll see the details from the previous order. We&rsquo;ll need to change the controller again so the order information is cleared when the order is successfully saved. We can do that by clearing the session information when the order is saved by setting both the <code>order_step</code> and <code>order_params</code> session variables to <code>nil</code>.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  session[:order_params].deep_merge!(params[:order]) if params[:order]
  @order = Order.new(session[:order_params])
  @order.current_step = session[:order_step]
  if params[:back_button]
    @order.previous_step
  elsif @order.last_step?
    @order.save
  else
    @order.next_step
  end
  session[:order_step] = @order.current_step
    
  if @order.new_record?
    render &#x27;new&#x27;
  else
    session[:order_step] = session[:order_params] = nil
    flash[:notice] = &quot;Order saved.&quot;
    redirect_to @order
  end
end
</pre>

<h3>Adding Validation</h3>

<p>The last thing we&rsquo;ll cover is how to deal with validations in the form. We&rsquo;ll give the <code>Order</code> model validation on the <code>shipping_name</code> and <code>billing_name</code> attributes.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
validates_presence_of :shipping_name
validates_presence_of :billing_name
</pre>

<p>We only want the validation error for each attribute to appear on the appropriate step and we can do this by adding an <code>if</code> condition to the validators.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
validates_presence_of :shipping_name, :if =&gt; lambda { |o| o.current_step == &quot;shipping&quot; }
validates_presence_of :billing_name, :if =&gt; lambda { |o| o.current_step == &quot;billing&quot; }
</pre>  

<p>We only want the form to change to the next (or previous) step if the order is valid and so we&rsquo;ll need to modify the <code>create</code> action in the controller again so that checks that the order is valid. We do this by wrapping the code that changes step and saves the record in an <code>if</code> statement.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  session[:order_params].deep_merge!(params[:order]) if params[:order]
  @order = Order.new(session[:order_params])
  @order.current_step = session[:order_step]
  if @order.valid?
    if params[:back_button]
      @order.previous_step
    elsif @order.last_step?
      @order.save
    else
      @order.next_step
    end
    session[:order_step] = @order.current_step
  end
  if @order.new_record?
    render &#x27;new&#x27;
  else
    session[:order_step] = session[:order_params] = nil
    flash[:notice] = &quot;Order saved.&quot;
    redirect_to @order
  end
end
</pre>

<p>If we try to create a new order now and try to submit the first step we&rsquo;ll see the error shown for the shipping field but not for the billing field.</p>

<div class="imageWrapper">
  <img src="/system/photos/397/original/E217I07.png" width="800" height="500" alt="Only the error for the shipping step is shown."/>
</div>

<p>Likewise if we then move on to the billing step and try to leave that blank we&rsquo;ll see only the error for that step.</p>

<div class="imageWrapper">
  <img src="/system/photos/398/original/E217I08.png" width="800" height="536" alt="Likewise on the billing step only the error for the billing infomation field is shown."/>
</div>

<p>We could tidy the validation up a little by moving the lambda expressions into methods called <code>shipping?</code> and <code>billing?</code>, like this.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
class Order &lt; ActiveRecord::Base
  attr_accessible :shipping_name, :billing_name
  attr_writer :current_step

  validates_presence_of :shipping_name, :if =&gt; :shipping?
  validates_presence_of :billing_name, :if =&gt; :billing?

  # other methods omittted.
    
  def shipping?
    current_step == &quot;shipping&quot;
  end
  
  def billing?
    current_step == &quot;billing&quot;
  end
end
</pre>

<p>It&rsquo;s also useful to have a method that validates all of the steps at once. To do this we can write an <code>all_valid?</code> method that loops through each step and checks that it is valid.</p>

<p class="codeFilePath">/app/models/order.rb</p>
<pre class="ruby">
def all_valid?
  steps.all? do |step|
    self.current_step = step
    valid?
  end
end
</pre>

<p>This way if we ever make changes to the validations or to the way the steps work we can ensure that no steps were invalidated in the process. We can use this new method in the controller to make sure that the order is only saved if all of the steps are valid.</p>

<p class="codeFilePath">/app/controllers/orders_controller.rb</p>
<pre class="ruby">
def create
  session[:order_params].deep_merge!(params[:order]) if params[:order]
  @order = Order.new(session[:order_params])
  @order.current_step = session[:order_step]
  if @order.valid?
    if params[:back_button]
      @order.previous_step
    elsif @order.last_step?
      @order.save if @order.all_valid?
    else
      @order.next_step
    end
    session[:order_step] = @order.current_step
  end
  if @order.new_record?
    render &#x27;new&#x27;
  else
    session[:order_step] = session[:order_params] = nil
    flash[:notice] = &quot;Order saved.&quot;
    redirect_to @order
  end
end
</pre>

<p>The handy thing about the <code>all_valid?</code> method is that it changes the step it&rsquo;s on so that if one of the steps isn&rsquo;t valid then that will become the current step so that the user is shown the first invalid step.</p>

<p>That&rsquo;s it for this episode on multistep forms. One thing to bear in mind is that we are storing the order parameters in a session which means that if a user has multiple windows or tabs open then the same session information will be shared across them. If you want the multiple tabs or windows to be treated separately then you might want to store the order parameters in the database and save the order model early, using the update action to save the various steps. Alternatively the parameters could be stored in hidden fields on the form.</p>

<p>Finally, a quick look at the create action shows that it&rsquo;s rather longer and more complicated than a method should be. While it&rsquo;s fine for the purposes on this demonstration, if this technique was to be put to use in a production application it would need some refactoring to tidy it up.</p>