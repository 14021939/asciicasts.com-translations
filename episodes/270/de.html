<p>Rails 3.1 bringt neue Features zur Authentifizierung mit sich. In dieser Folge werden wir euch einige dieser Funktionen vorstellen. Wir verwenden hierfür eine einfache Anwendung. Die Anwendung besteht aus einer Seite, welche momentan für jeden zugänglich ist, der die zugehörige URL kennt.</p>

<div class="imageWrapper">
  <img src="/system/photos/678/original/E270I01.png" width="813" height="533" alt="Die Seite, die wir schützen wollen."/>
</div>

<h3>HTTP Basic Authentication</h3>

<p>Wir wollen den Zugang zur der Seite einschränken, so dass sie nur von berechtigten Benutzern betrachtet werden kann. Damit kommen wir nicht daran vorbei irgend eine Art der Authentifizierung zu erstellen und die einfachste Möglichkeit ist hier die HTTP Basic Authentication. Rails 3.1 bietet dafür eine neue Variante. Das einzige was wir zu tun haben, ist den Controller der Seite zu ergänzen. Wir fügen einen Aufruf der Methode <code>http_basic_authenticate_with</code> mit den Optionen <code>:name</code> und <code>:password</code> hinzu.</p> 

<p class="codeFilePath">/app/controllers/secret_controller.rb</p>
<pre class="ruby">class SecretController &lt; ApplicationController
  http_basic_authenticate_with :name =&gt; &quot;frodo&quot;, :password =&gt; &quot;thering&quot;
  def index
  end
end</pre>

<p>Wenn wir die Authentifizierung auf bestimmte Actions beschränken wollen, können wir die Optionen <code>:only</code> oder <code>:except</code> verwenden. Natürlich würden wir in einer echten Anwendung den Benutzernamen und das Passwort nicht als Klartext im Quellcode belassen, sondern diese in eine Konfigurationsdatei auslagern. Aber für diese Beispielanwendung können sie hier stehen bleiben.</p>

<p>Wenn wir jetzt unsere Seite aufrufen, begrüßt uns ein Anmeldefenster, welches nur die eben über <code>http_basic_authenticate_with</code> vorgegebenen Anmeldedaten akzeptiert.</p>

<div class="imageWrapper">
  <img src="/system/photos/679/original/E270I02.png" width="816" height="537" alt="Die Seite fordert nun gültige Anmeldedaten."/>
</div>

<p>HTTP Basic ist zwar recht schlicht gehalten, dafür bietet es aber einen schnellen und leichten Weg Teile einer Anwendung zu schützen. Und mit Rails 3.1 ist es sogar noch einfacher einzusetzen.</p>

<h3>Die Verwendung von <code>secure_password</code></h3>

<p>Manchmal benötigen wir aber ein etwas umfangreicheres Autorisierungssystem, das auch mit mehreren Nutzern umgehen kann. Rails 3.1 hilft uns hier mit <code>secure_password</code> weiter.</p>

<p>In Folge 250 [<a href="http://railscasts.com/episodes/250-authentication-from-scratch">watch</a>, <a href="http://asciicasts.com/episodes/250-authentication-from-scratch">read</a>] hatten wir eine Authentifizierung von Grund auf selbst programmiert. Rails 3.1 macht dies jetzt ein wenig einfacher. Um das zu demonstrieren, werden wir jetzt die HTTP Basic Authentifizierung durch unsere eigene ersetzen.</p>

<p>Als erstes generieren wir ein Model <code>User</code> mit einer Emailadresse und einem Passwort.</p>

<pre class="terminal">$ rails g model user email:string password_digest:string</pre>

<p>Anschließend migrieren wir die Datenbank und erzeugen so die Nutzertabelle.</p>

<pre class="terminal">$ rake db:migrate</pre>

<p>The important thing here is that we call the field that will store passwords <code>password_digest</code>. Next we&rsquo;ll need to add a call to <code>has_secure_password</code> in the <code>User</code> model.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
end</pre>

<p>This adds methods to set and authenticate the entered password, adds validators for the password and password confirmation and also adds authentication functionality. The <code>password_digest</code> field we created earlier is used in the background to store the hashed password.</p> 

<p>By default there&rsquo;s no <code>validates_presence_of</code> validator for the password so we&rsquo;ll add one that fires when a new user is created.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<p>Normally we&rsquo;d want to validate the email address too but we won&rsquo;t to that here.</p>

<p>To allow users to create accounts we&rsquo;ll create a <code>UsersController</code>.</p>

<pre class="terminal">$ rails g controller users</pre>

<p>The code for the controller is fairly standard and looks like this:</p>

<p class="codeFilePath">/app/controllers/users_controller.rb</p>
<pre class="ruby">class UsersController &lt; ApplicationController
  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to root_url, :notice =&gt; &quot;Signed up!&quot;
    else
      render &quot;new&quot;
    end
  end
end</pre>

<p>The new view contains a form for signing up.</p>

<p class="codeFilePath">/app/views/users/new.html.erb</p>
<pre class="ruby">&lt;h1&gt;Sign Up&lt;/h1&gt;

&lt;%= form_for @user do |f| %&gt;
  &lt;% if @user.errors.any? %&gt;
    &lt;div class=&quot;error_messages&quot;&gt;
      &lt;h2&gt;Form is invalid&lt;/h2&gt;
      &lt;ul&gt;
        &lt;% for message in @user.errors.full_messages %&gt;
          &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :email %&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :password %&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :password_confirmation %&gt;
    &lt;%= f.password_field :password_confirmation %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;actions&quot;&gt;&lt;%= f.submit %&gt;&lt;/div&gt;
&lt;% end %&gt;</pre>

<p>If we try signing up and enter a password that doesn&rsquo;t match the confirmation we&rsquo;ll see the validation message that was provided by <code>has_secure_password</code>.</p>

<div class="imageWrapper">
  <img src="/system/photos/680/original/E270I03.png" width="800" height="501" alt="has_secure_password automatically provides us with a confirmation validator."/>
</div>

<p>When we enter a matching password confirmation we&rsquo;ll be signed up successfully.</p>

<p>Users can sign up but not yet sign in so next we&rsquo;ll create a login form with email and password fields.</p>

<p class="codeFilePath">/app/views/sessions/new.html.erb</p>
<pre class="ruby">&lt;h1&gt;Log in&lt;/h1&gt;

&lt;%= form_tag sessions_path do %&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= label_tag :email %&gt;
    &lt;%= text_field_tag :email, params[:email] %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= label_tag :password %&gt;
    &lt;%= password_field_tag :password %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;actions&quot;&gt;&lt;%= submit_tag &quot;Log in&quot; %&gt;&lt;/div&gt;
&lt;% end %&gt;</pre>

<p>Note that the form uses <code>form_tag</code> rather than <code>form_for</code> as we&rsquo;re not editing a resource here. The form is submitted to a <code>sessions_path</code> and so we&rsquo;ll need a new <code>SessionsController</code>.</p>

<pre class="terminal">$ rails g controller sessions</pre>

<p>This controller will have <code>new</code>, <code>create</code> and <code>destroy</code> actions so that users can log in and out.</p>

<p class="codeFilePath">/app/controllers/sessions_controller.rb</p>
<pre class="ruby">class SessionsController &lt; ApplicationController
  def new
  end

  def create
    if # authenticated?
      session[:user_id] = user.id
      redirect_to root_url, :notice =&gt; &quot;Logged in!&quot;
    else
      flash.now.alert = &quot;Invalid email or password&quot;
      render &quot;new&quot;
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_url, :notice =&gt; &quot;Logged out!&quot;
  end
end</pre>

<p>The <code>create</code> action isn&rsquo;t quite completed yet as we&rsquo;re yet to write the code that determines whether the user who&rsquo;s logging in is authenticated or not. This is where we can take advantage of what Rails 3.1 gives us with <code>secure_password</code>.</p>  

<p>The first thing we&rsquo;ll need to do is to fetch the user whose email address matches the value entered in the form. We can then call <code>authenticate</code> on that user, which is a method that <code>has_secure_password</code> gives us, passing in the password that was entered in the form. This method will check the password against the password digest in the database. If no matching user is found then <code>find_by_email</code> will return <code>nil</code> so we check that the user exists before authenticating them.</p>

<p class="codeFilePath">/app/controllers/sessions_controller.rb</p>
<pre class="ruby">def create
  user = User.find_by_email(params[:email])
  if user &amp;&amp; user.authenticate(params[:password])
    session[:user_id] = user.id
    redirect_to root_url, :notice =&gt; &quot;Logged in!&quot;
  else
    flash.now.alert = &quot;Invalid email or password&quot;
    render &quot;new&quot;
  end
end</pre>

<p>This is all we need to do to authenticate through <code>secure_password</code>. We can test this out by trying to log in. If we enter an incorrect password we won&rsquo;t be authenticated.</p>

<div class="imageWrapper">
  <img src="/system/photos/681/original/E270I04.png" width="800" height="390" alt="An error is thrown if the username or password are incorrect."/>
</div>

<p>If we log in with the correct credentials we&rsquo;ll be authenticated and redirected to the home page.</p>

<p>Elsewhere in our application we need to get the currently logged-in user so we&rsquo;ll add a <code>current_user</code> method in the <code>ApplicationController</code> and make it a helper method so that we can access it in the views. This method will fetch the current user from the session.</p>

<pre class="codeFilePath">/app/controllers/application_controller.rb</pre>
<pre class="ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  
  private
  
  def current_user
    @current_user ||= User.find(session[:user_id]) if session[:user_id]
  end
  
  helper_method :current_user
end</pre>

<p>What&rsquo;s really nice about this method of authentication is how simple the <code>User</code> model is, just two lines of code.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<p>By comparison the solution we created in episode 250 had a <a href="https://github.com/ryanb/railscasts-episodes/blob/master/episode-250/auth/app/models/user.rb">much more complex <code>User</code> model</a>. That said it would be wise to add an <code>attr_accessible</code> line to the model so that only the email, password and <code>password_confirmation</code> fields can be set through the user registration form.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  attr_accessible :email, :password, :password_confirmation
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<h3>Adding HTTPS</h3>

<p>If we&rsquo;re handling authentication in our applications we don&rsquo;t really want to send credentials over the wire in plain text so it&rsquo;s a good idea to use SSL and switch over to HTTPS. Prior to Rails 3.1 this had to be done either manually or through a plugin but now there&rsquo;s a much simpler way to implement it.</p>

<p>To restrict a controller so that it has to be accessed with HTTPS we simply need to add a call to the <code>force_ssl</code> class method. If want to restrict this only certain actions within a controller we can use the <code>:only</code> or <code>:except</code> options like we would when using a <code>before_filter</code>.</p> 

<p class="codeFilePath">/app/controllers/application_controller.rb</p>
<pre class="ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  force_ssl
  private
  
  def current_user
    @current_user ||= User.find(session[:user_id]) if session[:user_id]
  end
  
  helper_method :current_user
end</pre>

<p>The <code>force_ssl</code> method only forces HTTPS in test or production modes. If we restart our application&rsquo;s server in production mode and reload the signup page it will try to redirect to the SSL version.</p>

<div class="imageWrapper">
  <img src="/system/photos/682/original/E270I05.png" width="795" height="280" alt="The page now requires SSL."/>
</div>

<p>This fails as our server doesn&rsquo;t support HTTPS but if it did we&rsquo;d see the secure version of this page.</p>

<p>That&rsquo;s it for this episode on authentication in Rails 3.1. All of the new authentication additions it provides make it much easier to add authentication to our Rails applications.</p>
