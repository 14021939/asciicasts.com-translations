<p>Rails 3.1 bringt neue Features zur Authentifizierung mit sich. In dieser Folge werden wir euch einige dieser Funktionen vorstellen. Wir verwenden hierfür eine einfache Anwendung. Die Anwendung besteht aus einer Seite, welche momentan für jeden zugänglich ist, der die zugehörige URL kennt.</p>

<div class="imageWrapper">
  <img src="/system/photos/678/original/E270I01.png" width="813" height="533" alt="Die Seite, die wir schützen wollen."/>
</div>

<h3>HTTP Basic Authentication</h3>

<p>Wir wollen den Zugang zu der Seite einschränken, so dass sie nur von berechtigten Benutzern betrachtet werden kann. Es ist also notwendig, dass wir einen Nutzer authentifizieren können und die einfachste Möglichkeit ist hier die HTTP Basic Authentication. Rails 3.1 bietet dafür eine neue Variante. Das einzige was wir zu tun haben, ist den Controller der Seite zu ergänzen. Wir fügen einen Aufruf der Methode <code>http_basic_authenticate_with</code> mit den Optionen <code>:name</code> und <code>:password</code> hinzu.</p> 

<p class="codeFilePath">/app/controllers/secret_controller.rb</p>
<pre class="ruby">class SecretController &lt; ApplicationController
  http_basic_authenticate_with :name =&gt; &quot;frodo&quot;, :password =&gt; &quot;thering&quot;
  def index
  end
end</pre>

<p>Wenn wir die Authentifizierung auf bestimmte Actions beschränken wollen, können wir die Optionen <code>:only</code> oder <code>:except</code> verwenden. Natürlich würden wir in einer echten Anwendung den Benutzernamen und das Passwort nicht als Klartext im Quellcode belassen, sondern diese in eine Konfigurationsdatei auslagern. Aber für diese Beispielanwendung können wir sie hier belassen.</p>

<p>Wenn wir jetzt unsere Seite aufrufen, begrüßt uns ein Anmeldefenster, welches nur die eben über <code>http_basic_authenticate_with</code> vorgegebenen Anmeldedaten akzeptiert.</p>

<div class="imageWrapper">
  <img src="/system/photos/679/original/E270I02.png" width="816" height="537" alt="Die Seite fordert nun gültige Anmeldedaten."/>
</div>

<p>HTTP Basic ist zwar recht schlicht gehalten, dafür bietet es aber einen schnellen und einfachen Weg Teile einer Anwendung zu schützen. Und mit Rails 3.1 ist es sogar noch leichter einzusetzen.</p>

<h3>Die Verwendung von <code>secure_password</code></h3>

<p>Manchmal benötigen wir aber ein etwas umfangreicheres Autorisierungssystem, das auch mit mehreren Nutzern umgehen kann. Rails 3.1 hilft uns hier mit <code>secure_password</code> weiter.</p>

<p>In Folge 250 [<a href="http://railscasts.com/episodes/250-authentication-from-scratch">watch</a>, <a href="http://asciicasts.com/episodes/250-authentication-from-scratch">read</a>] hatten wir eine Authentifizierung von Grund auf selbst programmiert. Rails 3.1 macht dies jetzt ein wenig einfacher. Um das zu demonstrieren, werden wir jetzt die HTTP Basic Authentifizierung durch unsere eigene ersetzen.</p>

<p>Als erstes generieren wir für unsere Nutzer ein Model <code>User</code> mit einer Emailadresse und einem Passwort.</p>

<pre class="terminal">$ rails g model user email:string password_digest:string</pre>

<p>Anschließend migrieren wir die Datenbank und erzeugen so die Nutzertabelle.</p>

<pre class="terminal">$ rake db:migrate</pre>

<p>Wichtig hierbei ist, dass wir das Feld zur Speicherung des Passworts <code>password_digest</code> nennen. Als nächstes müssen wir im Model <code>User</code> ein Aufruf von <code>has_secure_password</code> hinzufügen.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
end</pre>

<p>Hierdurch werden Methoden zum Setzen und Überprüfen des eingegebenen Passworts, Validatoren für das Passwort und die Passwortbestätigung (confirmation), sowie Authentifizierungsfunktionalität hinzugefügt. Das Feld <code>password_digest</code>, dass wir vorhin angelegt haben, dient zur Speicherung des Passworts als Hash.</p>

<p>Standardmäßig existiert noch kein Validator <code>validates_presence_of</code> der sicherstellt, dass bei der Erstellung eines Nutzers überhaupt ein Passwort eingegeben wurde. Also erstellen wir uns als nächstes einen solchen.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<p>In der Regel würden wir auch die Emailadresse validieren. Das sparen wir uns aber hier.</p>

<p>Damit sich Nutzer auch einen Account erstellen können, erzeugen wir als nächsten den Nutzercontroller.</p>

<pre class="terminal">$ rails g controller users</pre>

<p>Der Quelltext des Controllers enthält nichts besonderes:</p>

<p class="codeFilePath">/app/controllers/users_controller.rb</p>
<pre class="ruby">class UsersController &lt; ApplicationController
  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to root_url, :notice =&gt; &quot;Signed up!&quot;
    else
      render &quot;new&quot;
    end
  end
end</pre>

<p>Die neue View enthält ein Formular, wo sich die Nutzer registrieren können.</p>

<p class="codeFilePath">/app/views/users/new.html.erb</p>
<pre class="ruby">&lt;h1&gt;Sign Up&lt;/h1&gt;

&lt;%= form_for @user do |f| %&gt;
  &lt;% if @user.errors.any? %&gt;
    &lt;div class=&quot;error_messages&quot;&gt;
      &lt;h2&gt;Form is invalid&lt;/h2&gt;
      &lt;ul&gt;
        &lt;% for message in @user.errors.full_messages %&gt;
          &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :email %&gt;
    &lt;%= f.text_field :email %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :password %&gt;
    &lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :password_confirmation %&gt;
    &lt;%= f.password_field :password_confirmation %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;actions&quot;&gt;&lt;%= f.submit %&gt;&lt;/div&gt;
&lt;% end %&gt;</pre>

<p>Wenn wir nun versuchen, uns mit zwei nicht identischen Passwörtern zu registrieren, sehen wir die Validatoren in Aktion, welche durch den Aufruf von <code>has_secure_password</code> bereitgestellt wurden.</p>

<div class="imageWrapper">
  <img src="/system/photos/680/original/E270I03.png" width="800" height="501" alt="has_secure_password stellt uns automatisch einen Confirmationvalidatior bereit."/>
</div>

<p>Geben wir beide Passwörter korrekt ein, werden wir erfolgreich registriert.</p>

<p>Die Nutzer können sich nun zwar registrieren, aber noch nicht anmelden. Also erzeugen wir als nächstes ein Anmeldeformular zur Eingabe von Emailadresse und Passwort.</p>

<p class="codeFilePath">/app/views/sessions/new.html.erb</p>
<pre class="ruby">&lt;h1&gt;Log in&lt;/h1&gt;

&lt;%= form_tag sessions_path do %&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= label_tag :email %&gt;
    &lt;%= text_field_tag :email, params[:email] %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= label_tag :password %&gt;
    &lt;%= password_field_tag :password %&gt;
  &lt;/div&gt;
  &lt;div class=&quot;actions&quot;&gt;&lt;%= submit_tag &quot;Log in&quot; %&gt;&lt;/div&gt;
&lt;% end %&gt;</pre>

<p>Da wir kein Model bearbeiten, verwenden wir anstelle des <code>form_for</code> den <code>form_tag</code> Helfer. Das Formular wird an <code>sessions_path</code> gesendet. Also benötigen wir als nächstes einen Controller für Sessions.</p>

<pre class="terminal">$ rails g controller sessions</pre>

<p>Damit Nutzer sich an- und abmelden können, besitzt der Controller <code>new</code>, <code>create</code> und <code>destroy</code> Actions.</p>

<p class="codeFilePath">/app/controllers/sessions_controller.rb</p>
<pre class="ruby">class SessionsController &lt; ApplicationController
  def new
  end

  def create
    if # authenticated?
      session[:user_id] = user.id
      redirect_to root_url, :notice =&gt; &quot;Logged in!&quot;
    else
      flash.now.alert = &quot;Invalid email or password&quot;
      render &quot;new&quot;
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_url, :notice =&gt; &quot;Logged out!&quot;
  end
end</pre>

<p>Die <code>create</code> Action ist noch nicht ganz vollständig. Wir müssen noch prüfen, ob der Nutzer das richtige Passwort eingegeben hat. Hier hilft uns die neue <code>secure_password</code> Funktionalität aus Rails 3.1.</p>

<p>Als erstes suchen wir uns den zur eingegebenen Emailadresse passenden Nutzer. Dank <code>has_secure_password</code> verfügen Nutzer nun über die Methode <code>authenticate</code>. Ihr übergeben wir das Passwort und lassen es gegen das verschlüsselte Passwort in der Datenbank abgleichen. Konnte erst gar kein passender Nutzer gefunden werden, liefert <code>find_by_email</code> <code>nil</code> zurück. Deshalb prüfen wir erst einmal, ob der Nutzer überhaupt existiert, bevor wir ihn authentifizieren.</p>

<p class="codeFilePath">/app/controllers/sessions_controller.rb</p>
<pre class="ruby">def create
  user = User.find_by_email(params[:email])
  if user &amp;&amp; user.authenticate(params[:password])
    session[:user_id] = user.id
    redirect_to root_url, :notice =&gt; &quot;Logged in!&quot;
  else
    flash.now.alert = &quot;Invalid email or password&quot;
    render &quot;new&quot;
  end
end</pre>

<p>Mehr ist nicht notwendig, um einen Nutzer über <code>secure_password</code> zu authentifizieren. Zum Testen versuchen wir uns einfach anzumelden. Geben wir ein falsches Passwort ein, werden wir auch nicht authentifiziert.</p>

<div class="imageWrapper">
  <img src="/system/photos/681/original/E270I04.png" width="800" height="390" alt="An error is thrown if the username or password are incorrect."/>
</div>

<p>Geben wir hingegen gültige Daten ein, werden wir angemeldet und zur Startseite weitergeleitet.</p>

<p>Um überall in unserer Anwendung Zugriff auf den aktuellen Nutzer zu haben, erstellen wir die Methode <code>current_user</code> im <code>ApplicationController</code> und machen aus ihr eine Helfermethode, sodass sie in den Views verfügbar ist. Die Methode holt sich den aktuell angemeldeten Nuter aus der Session.</p> 

<pre class="codeFilePath">/app/controllers/application_controller.rb</pre>
<pre class="ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  
  private
  
  def current_user
    @current_user ||= User.find(session[:user_id]) if session[:user_id]
  end
  
  helper_method :current_user
end</pre>

<p>Wirklich schön an dieser Form der Authentifizierung ist das einfache <code>User</code> Model. Es besteht gerade einmal aus zwei Codezeilen.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<p>Unsere Version aus Folge 250 hatte ein <a href="https://github.com/ryanb/railscasts-episodes/blob/master/episode-250/auth/app/models/user.rb">deutlich komplexeres<code>User</code> Model</a>. Unabhängig davon ist es noch sinnvoll durch die Zeile <code>attr_accessible</code> im Model den möglichen Zugriff auf <code>email</code>, <code>password</code> und <code>password_confirmation</code> zu beschränken.</p>

<p class="codeFilePath">/app/models/user.rb</p>
<pre class="ruby">class User &lt; ActiveRecord::Base
  attr_accessible :email, :password, :password_confirmation
  has_secure_password
  validates_presence_of :password, :on =&gt; :create
end</pre>

<h3>Adding HTTPS</h3>

<p>If we&rsquo;re handling authentication in our applications we don&rsquo;t really want to send credentials over the wire in plain text so it&rsquo;s a good idea to use SSL and switch over to HTTPS. Prior to Rails 3.1 this had to be done either manually or through a plugin but now there&rsquo;s a much simpler way to implement it.</p>

<p>To restrict a controller so that it has to be accessed with HTTPS we simply need to add a call to the <code>force_ssl</code> class method. If want to restrict this only certain actions within a controller we can use the <code>:only</code> or <code>:except</code> options like we would when using a <code>before_filter</code>.</p> 

<p class="codeFilePath">/app/controllers/application_controller.rb</p>
<pre class="ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery
  force_ssl
  private
  
  def current_user
    @current_user ||= User.find(session[:user_id]) if session[:user_id]
  end
  
  helper_method :current_user
end</pre>

<p>The <code>force_ssl</code> method only forces HTTPS in test or production modes. If we restart our application&rsquo;s server in production mode and reload the signup page it will try to redirect to the SSL version.</p>

<div class="imageWrapper">
  <img src="/system/photos/682/original/E270I05.png" width="795" height="280" alt="The page now requires SSL."/>
</div>

<p>This fails as our server doesn&rsquo;t support HTTPS but if it did we&rsquo;d see the secure version of this page.</p>

<p>That&rsquo;s it for this episode on authentication in Rails 3.1. All of the new authentication additions it provides make it much easier to add authentication to our Rails applications.</p>
