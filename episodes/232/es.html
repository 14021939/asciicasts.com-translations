<p>Este episodio será una continuación del de la semana pasada y en él seguiremos examinando la implementación del código de rutas Rails 3.  Al final del episodio anterior el fichero de rutas de nuestra aplicación tenía el siguiente aspecto:</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  match &#x27;products&#x27;, :to =&gt; ProductsController.action(&quot;index&quot;)
  match &#x27;products/recent&#x27;
end
</pre>

<p>En el último episodio, examinamos la implementación del método <code>match</code> y vimos lo que ocurre cuando se invoca <code>match</code> en el fichero de rutas.   En este episodio estudiaremos otros métodos que también pueden ser usados.</p>

<p>Si miramos el código fuente de Rails 3.0 veremos que la lógica de las rutas está en la carpeta <code>actionpack/lib/actiondispatch/routing</code> y de todos los archivos nos centraremos en el de la clase <code>Mapper</code> porque, como ya vimos en el episodio anterior, el bloque dentro del fichero de rutas se ejecuta en el ámbito de esta clase.  Esto quiere decir que cualquier método que sea llamado en dicho bloque se ejecuta en una instancia de <code>Mapper</code> y por tanto en nuestros ficheros de rutas podemos invocar cualquier método de dicha clase.</p>

<p>El código de la clase <code>Mapper</code> puede resultarnos abrumador.  Son casi 1000 complejas líneas de código, pero la buena noticia es que se trata del fichero más grande de todo el sistema de rutas de Rails por lo que si somos capaces de entender lo que ocurre y cómo funciona esta clase habremos conseguido entender bastante bien cómo funcionan las rutas de Rails.</p>

<p>Para ver el código a vista de pájaro lo colapsaremos utilizando la utilidad de plegado de código de TextMate.  Si pulsamos <code>Command-Option-0</code> se plegará todo.  A continuación expandiremos el móduo raíz <code>ActionDispatch</code>, su submódulo <code>Routing</code> y por último la clase <code>Mapping</code> propiamente dicha.</p>


<div class="imageWrapper">
  <img src="/system/photos/474/original/E232I01.png" width="732" height="798" alt="Estrucutra de la clase Mapper."/>
</div>

<p>Los primeros dos elementos de la clase <code>Mapper</code> son las definiciones de clase de <code>Constraints</code> y <code>Mapping</code>   Ya las vimos en el episodio anterior pero lo que merece la pena ver ahora es que estas clases están anidadas dentro de la clase <code>Mapper</code>.  ¿Por qué anidar las clases de esta manera?  Esto no tiene nada de mágico; la clase <code>Constraints</code> está toalmente separada de la clase <code>Mapper</code>.  El motivo por el que las clases se anidan es porque los nombres delas clases <code>Constraints</code> y <code>Mapping</code> quedan definidos dentro del ámbito del espacio de nombres de <code>Mapper</code>.  En Ruby no hay ningún tipo de herencia ni relación entre las clases cuando se anidan de esta forma.</p>

<p>Si bajamos hasta la clase tenemos dos métodos, <code>self.normalize_path</code> y <code>self.normalize_name</code>, que son métodos de utilidad que se invocan dentro de la clase.  Debajo hay un grupo de módulos:</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
module Base...

module HttpHelpers...

module Scoping...

module Resources...

module Shorthand...

include Base
include HttpHelpers
include Scoping
include Resources
include Shorthand
</pre>

<p>Estos cinco módulos están incluidos dentro de la clase <code>Mapper</code>.  Su código está en módulos simplemente para organizar mejor el código de la clase.</p>

<h3>Base</h3>

<p>Ya vimos el primer módulo, <code>Base</code>, en el episodio anterior.  Contien los métodos <code>match</code> y <code>root</code> (que utiliza a <code>match</code>), así como el método <code>mount</code> que nos da otra manera de mapear una aplicación Rack sobre una URL.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
module Base
  def initialize(set) #:nodoc:

  def root(options = {})
    match &#x27;/&#x27;, options.reverse_merge(:as =&gt; :root)
  end

  def match(path, options=nil)...

  def mount(app, options = nil)...

  def default_url_options=(options)...
  alias_method :default_url_options, :default_url_options=
end
</pre>

<h3>HttpHelpers</h3>

<p>El siguiente módulo es <code>HttpHelpers</code>, que es donde se definen los métodos  <code>get</code>, <code>post</code>, <code>put</code> y <code>delete</code>.  Estos métodos se utilizan para mapear las rutas a ciertos tipos de petición.</p> 

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
module HttpHelpers
  def get(*args, &amp;block)
    map_method(:get, *args, &amp;block)
  end

  def post(*args, &amp;block)
    map_method(:post, *args, &amp;block)
  end

  def put(*args, &amp;block)
    map_method(:put, *args, &amp;block)
  end

  def delete(*args, &amp;block)
    map_method(:delete, *args, &amp;block)
  end

  def redirect(*args, &amp;block)...

  private
  def map_method(method, *args, &amp;block)
     options = args.extract_options!
     options[:via] = method
     args.push(options)
     match(*args, &amp;block)
     self
   end
end
</pre>

<p>Todos estos métodos invocan al método privado <code>map_method</code>.  Este métodos establece la opción <code>:via</code> de acuerdo al método que se le pasa y a continuación invoca a <code>match</code>. Nótese que en el código de rutas gran parte de los métodos delegan sobre el método <code>match</code>, pasando y modificando sus diferentes opciones.  Por tanto si queremos que una ruta sólo responda a una petición GET podríamos hacerlo de esta manera, con la opción <code>via</code>.</p>

<pre class="ruby">
match &#x27;products/recent&#x27;, :via =&gt; :get
</pre>

<p>En la práctica haríamos esto utilizando la opción <code>get</code>, que creará una ruta con dicha opción.</p>

<pre class="ruby">
get &#x27;products/recent&#x27;
</pre>

<p>Los métodos <code>post</code>, <code>put</code> y <code>delete</code> funcionan de la misma manera que el método <code>get</code> para los otros tipos de petición.  Sin embargo el método <code>redirect</code> se distingue de los otros porque devuelve una aplicación Rack, lo que es más interesante.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def redirect(*args, &amp;block)
  options = args.last.is_a?(Hash) ? args.pop : {}

  path      = args.shift || block
  path_proc = path.is_a?(Proc) ? path : proc { |params| path % params }
  status    = options[:status] || 301

  lambda do |env|
    req = Request.new(env)

    params = [req.symbolized_path_parameters]
    params &lt;&lt; req if path_proc.arity &gt; 1

    uri = URI.parse(path_proc.call(*params))
    uri.scheme ||= req.scheme
    uri.host   ||= req.host
    uri.port   ||= req.port unless req.standard_port?

    body = %(&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;#{ERB::Util.h(uri.to_s)}&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;)

    headers = {
      &#x27;Location&#x27; =&gt; uri.to_s,
      &#x27;Content-Type&#x27; =&gt; &#x27;text/html&#x27;,
      &#x27;Content-Length&#x27; =&gt; body.length.to_s
    }

    [ status, headers, [body] ]
  end
end
</pre>

<p>El método construye la aplicación Rack devuelta con un <em>array</em> formado por un valor de estado, algunas cabeceras y el cuerpo.  El código de estado por defecto vale <code>301</code>, que es hará que el navegador efectúe una redirección <code>301 Moved Permanently</code>.  Podemos utilizar el método <code>redirect</code> directamente en nuestro archivo de rutas si queremos que una URL redirija a otra.  En nuestra fichero de rutas ya existe una ruta que utiliza el parámetro <code>:to</code>, y dicho parámetro recibe una aplicación Rack</p>

<pre class="ruby">
match &#x27;products&#x27;, :to =&gt; ProductsController.action(&quot;index&quot;)
</pre>

<p>Dado que la opción <code>redirect</code> devuelve una aplicación Rack podemos utilizar para redirigir a una nueva URL de esta forma:</p>

<pre class="ruby">
match &#x27;products&#x27;, :to =&gt; redirect(&quot;/items&quot;)
</pre>

<p>Esta funcionalidad resulta bastante útil cuando estamos cambiando las URLs de nuestra aplicación pero queremos seguir soportando las URLs anteriores.  Se puede usar <code>redirect</code> para dirigir estas URLs antiguas a las nuevas.</p>

<h3>Abreviaturas</h3>

<p>Los siguientes módulos que aparecen son <code>Scoping</code> y <code>Resources</code>, que veremos en breve.  Pero de momento nos fijaremos en el módulo <code>Shorthand</code>.  Se trata de un módulo de interés porque redefine el método <code>match</code>, que venía definido en el módulo <code>Base</code>.  Este método <code>match</code> soporta una sintaxis diferente para las opciones que puede recibir.  El método abreviado es una forma alternativa de escribir la opción <code>:to</code> en una ruta, como hicimos en la ruta <code>redirect</code> que escribimos anteriormente.</p>

<pre class="ruby">
match &#x27;products&#x27;, :to =&gt; redirect(&#x27;/items&#x27;)
</pre>

<p>Se trata de algo habitual en los ficheros de ruta, y la sintaxis abreviada nos permite escribir la ruta con un <em>hash</em> sencillo consturido a partir de la ruta y a dónde debería apuntar.  Al igual que con la sintaxis de ruta completa podemos añadir parámetros al final de la ruta</p>

<pre class="ruby">
match &#x27;products&#x27; =&gt; redirect(&#x27;/items&#x27;)
</pre>

<p>El método <code>match</code> de <code>Shorthand</code> establece el valor del párámetro <code>:to</code> si no lo está ya.  A continuación invoca a <code>super</code> pero como <code>Mapper</code> no hereda de otra clase, ¿qué se supone que tiene que hace rla llamada a <code>super</code> en este caso?</p>

<p class="ruby">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
module Shorthand
  def match(*args)
    if args.size == 1 &amp;&amp; args.last.is_a?(Hash)
      options  = args.pop
      path, to = options.find { |name, value| name.is_a?(String) }
      options.merge!(:to =&gt; to).delete(path)
      super(path, options)
    else
      super
    end
  end
end
</pre>

<p>Cuando en Ruby se usa el método <code>super</code> de esta manera, el intérprete buscará un método con el mismo nombre que haya sido definido en un módulo anterior.  El módulo <code>Shorthand</code> es el último que se define en la lista de módulos incluidos en <code>Mapper</code> por lo que Ruby buscará un método <code>match</code> definido en los módulos anteriores para delegar la llamada.  En este caso, invocará a <code>match</code> en el módulo <code>Base</code>.</p>

<p>Esta técnica se utiliza con frecuencia en el código fuente de Rails 3.  Las versiones anteriores de Rails utilizaban <code>alias_method_chain</code> para redefinir comportamientos específicos pero ahora con Rails 3 se puede utilizar simplemente <code>super</code>.</p>

<h3>Recursos</h3>

<p>A continuación veremos el módulo <code>Resources</code> Como cabría esperar, este módulo contiene el método <code>resources</code> y todos los métodos asociados.  Este método se usa en los ficheros de rutas para establecer rutas RESTful.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>

<pre class="ruby">
def resources(*resources, &amp;block)
  options = resources.extract_options!

  if apply_common_behavior_for(:resources, resources, options, &amp;block)
    return self
  end

  resource_scope(Resource.new(resources.pop, options)) do
    yield if block_given?

    collection_scope do
      get  :index if parent_resource.actions.include?(:index)
      post :create if parent_resource.actions.include?(:create)
    end

    new_scope do
      get :new
    end if parent_resource.actions.include?(:new)

    member_scope  do
      get    :edit if parent_resource.actions.include?(:edit)
      get    :show if parent_resource.actions.include?(:show)
      put    :update if parent_resource.actions.include?(:update)
      delete :destroy if parent_resource.actions.include?(:destroy)
    end
  end

  self
end
</pre>

<p>Se trata de un método ciertamente complejo pero se puede comprender el sentido del mismo viendo la estructura general del mismo.  Hay un par de métodos de colección, <code>get :index</code> y <code>post :create</code>, hay un método <code>get :new</code> y finalmente <code> <code>get :edit</code>, <code>get :show</code>, <code>put :update</code> and <code>delete :destroy</code>.  Deberían resultar familiares porque son las famosas siete acciones REST que se crean para un controlador cuando se invoca el método <code>resources</code> en el fichero de rutas.</code>
	
<p>Obsérvese la primera línea en el bloque <code>resource_scope</code> del método.   Si se pasa un bloque a este método lo primero que hará será <code>yield</code> sobre dicho bloque antes de crear las acciones REST.  Esto nos permite crear nuestras propias acciones en el fichero de rutas.  Por ejemplo podríamos añadir una nueva ruta de colección que devuelva los productos con descuento.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  match &#x27;products&#x27;, :to =&gt; redirect(&#x27;/items&#x27;)
  get &#x27;products/recent&#x27;
  resources :products do
    collection do:
      get :discounted
    end
  end
end
</pre>

<p>El código dentro del bloque que se pasa a <code>resources</code> será ejecutado por la llamada <code>yield</code> en <code>resource_scope</code>, tras lo cual se definen las siete rutas REST.</p>

<p>Si vemos los bloques del fichero de rutas de arriba podríamos pensar que cada vez que creamos un nuevo bloque el objeto <code>Mapper</code> cambia, pero no es el caso, por lo que llamar a <code>get</code> en el bloque de mayor anidamiento es lo mismo que hacerlo fuera.  Lo que se maneja es un ámbito diferente.</p>

<p>Si se le echa otro vistazo al método  <code>resources</code> en el código fuente de Rails veremos que hace una llamada a <code>collection_scope</code> cuando define las acciones <code>index</code> y <code>create</code> pero en nuestro fichero de rutas tan sólo usamos <code>collection</code>.  ¿Cuál es la diferencia?  No mucha.  Si miramos el método <code>collection</code> de la clase <code>Mapper</code> veremos que delega en <code>collection_scope</code>.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def collection
  unless @scope[:scope_level] == :resources
    raise ArgumentError, &quot;can&#x27;t use collection outside resources scope&quot;
  end

  collection_scope do
    yield
  end
end
</pre>

<p>Echemos otro vistazo a nuestro fichero de rutas.</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  match &#x27;products&#x27;, :to =&gt; redirect(&#x27;/items&#x27;)
  get &#x27;products/recent&#x27;
  resources :products do
    collection do:
      get :discounted
    end
  end
end
</pre>

<p>Ambas llamadas invocan al mismo método pero la que está dentro del bloque <code>collection</code> asumirá un comportamiento adicional según su ámbito dentro de los bloques <code>resources</code> y <code>collection</code>.</p>

<p>Si regresamos al módulo <code>Resourcese</code> veremos un viejo conocido, el método <code>match</code>, en cuya redefinición se añade el comportamiento adicional basado en recursos:</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def match(*args)
  options = args.extract_options!.dup
  options[:anchor] = true unless options.key?(:anchor)

  if args.length &gt; 1
    args.each { |path| match(path, options.dup) }
    return self
  end

  on = options.delete(:on)
  if VALID_ON_OPTIONS.include?(on)
    args.push(options)
    return send(on){ match(*args) }
  elsif on
    raise ArgumentError, &quot;Unknown scope #{on.inspect} given to :on&quot;
  end

  if @scope[:scope_level] == :resources
    args.push(options)
    return nested { match(*args) }
  elsif @scope[:scope_level] == :resource
    args.push(options)
    return member { match(*args) }
  end

  action = args.first
  path = path_for_action(action, options.delete(:path))

  if action.to_s =~ /^[\w\/]+$/
    options[:action] ||= action unless action.to_s.include?(&quot;/&quot;)
    options[:as] = name_for_action(action, options[:as])
  else
    options[:as] = name_for_action(options[:as])
  end

  super(path, options)
end
</pre>

<p>La línea que comprueba el ámbito actual para ver si es <code>resources</code> aparece más o menos a la mitad del bloque.  En tal caso, añade un comportamiento diferente.  La lógica es basntate compleja, y lo único que nos hace falta saber es que el módulo <code>Resources</code> redefine el método <code>match</code>.  Obsérvese que al final vuelve a invocar al método <code>super</code> para invocar al método <code>match</code> en <code>Base</code>.  Recordemos que <code>get</code> invoca a <code>match</code> y es aquí donde se ubica la funcionalidad adicional para <code>get</code> y los otros métodos que están definidos en <code>resources</code>.</p>

<h3>Ámbitos</h3>

<p>Ya hemos llegado al último método de la clase <code>Mapping</code>: <code>Scoping</code>.  Siempre que hay un bloque dentro de nuestro archivo de rutas hay una llamada implícita al método <code>scope</code> de <code>Scoping</code>. Esto quiere decir que definirá cierto comportamiento adicional para el código que está incluido dentro de ese bloque.</p>

<p>Junto al método <code>scope</code> hay otros métodos, que delegan todos sobre <code>scope</code>.</p>

<p class="codeFilePath">rails/actionpack/lib/action_dispatch/routing/mapper.rb</p>
<pre class="ruby">
def initialize(*args) #:nodoc:
  @scope = {}
  super
end

def controller(controller, options={})
  options[:controller] = controller
  scope(options) { yield }
end

def namespace(path, options = {})
  path = path.to_s
  options = { :path =&gt; path, :as =&gt; path, :module =&gt; path,
              :shallow_path =&gt; path, :shallow_prefix =&gt; 			path }.merge!(options)
  scope(options) { yield }
end

def constraints(constraints = {})
  scope(:constraints =&gt; constraints) { yield }
end

def defaults(defaults = {})
  scope(:defaults =&gt; defaults) { yield }
end
</pre>

<p>Estos métodos son todos bastnate sencillos y delegan sobre un método más genérico estableciendo primero algunas opciones.  Por ejemplo <code>defaults</code> invoca a <code>scope</code> después de establecer opciones por defecto, e igualmente <code>constraints</code> invoca a <code>scope</code> con ciertas opciones de restricción.  El método <code>namespace</code> es un poco más complicado pero en esencia hace lo mismo.  El módulo tmabién tiene un método <code>initialize</code> que sólo crea una variable de instancia (<code>@scope</code>) y le asigna un <em>hash</em> vacío.  Cabe preguntarse el motivo de un método <code>initialize</code> en un módulo, ya que los módulos no se instancian. Esto es cierto, pero en este caso estamos redefiniendo el comportamiento de un método.  Cuando el método <code>Scoping</code> se incluye en la clase <code>Mapper</code>, este método <code>initialize</code> reemplazará al ya existente, añadiendo la variable <code>@scope</code> y luego invocando a <code>super</code>.</p>

<p>Por último tenemos el método <code>scope</code> propiamente dicho, que es donde tiene lugar todo esto.  Se trata por tanto de un método bastante complejo pero en esencia lo que hace es rellenar la variable <code>@scope</code> con la información del ámbito en el que se encuentra para que pueda ser usada dentro de cualquier invocación a <code>match</code> que tengamos.</p>

<p>Este es el funcionamiento básico de los bloques en el fichero de rutas.  Si definimos rutas así:</p>

<p class="codeFilePath">/config/routes.rb</p>
<pre class="ruby">
Store::Application.routes.draw do
  controller :products do
    match #...
  end  
end
</pre>

<p>Cada vez que se llame a <code>match</code> en el bloque <code>controller</code> (y recordemos que delega a <code>scope</code>) la opción <code>controller</code> se propagará automáticamente.</p>

<p>Eso es todo por este episodio.  Esperamos que sirva para tener una idea de lo que hacen los distintos métodos disponbibles en el fichero de rutas.  Aunque hay muchos métodos disponibles la mayoría de ellos simplemente delegan en <code>match</code> o <code>scope</code> pasándoles ciertas opciones adicionales.</p>